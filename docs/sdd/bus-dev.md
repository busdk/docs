---
title: "bus-dev — developer workflows: commit, work, spec, e2e (SDD)"
description: "Bus Dev is a developer-only companion that centralizes workflow logic that module repositories would otherwise duplicate in scripts/ — module scaffolding, commit workflows, planning, agent-runner workflows, AGENTS.md refinement, and e2e test scaffolding."
---

## bus-dev — developer workflows: commit, work, spec, e2e

### Introduction and Overview

Bus Dev is a developer-only companion module that centralizes the workflow logic that module repositories would otherwise duplicate in `scripts/`: module scaffolding, commit workflows, planning from documentation coverage gaps, agent-runner workflows, AGENTS.md refinement, and end-to-end test scaffolding. It provides a single entry point so behavior and prompts stay consistent and maintainable in one place, and module repositories can rely on `bus dev` instead of copying and maintaining per-repo scripts. Bus Dev does not implement agentic operations itself: it depends on the [bus-agent](./bus-agent) module through Go library access for all agent runtime execution, prompt-template rendering, runtime detection, and installation references. Bus Dev owns workflow semantics, embedded prompt content, repository and module resolution, and the commit workflow; bus-agent owns the runner abstraction, backends, and execution contract.

The problem it solved was duplication and drift: each BusDK module used to ship its own `scripts/commit.sh`, `scripts/work.sh`, `scripts/refine-agents.sh`, and `scripts/e2e.sh` (or equivalents), with slightly different behavior and prompts. Bus Dev consolidates that logic into one binary, `bus-dev`, invoked through the dispatcher as `bus dev …`, with embedded prompts and deterministic behavior.

Scope and boundaries are unambiguous. Bus Dev operates on source code repositories and developer workflows only. It does not operate on accounting datasets, workspace CSV, or schemas. It is not part of the end-user bookkeeping command surface. End users running `bus accounts`, `bus journal`, or `bus validate` never need `bus dev`; it exists for contributors and automation that work inside BusDK module Git repositories.

This module is an explicit exception to the BusDK-wide non-goal NG-001: "BusDK does not execute Git commands or commit changes." That non-goal applies to the accounting and workspace toolchain. Bus Dev is isolated to developer tooling and enforces strict safety constraints: no remote Git operations (no push, pull, fetch, clone, or submodule update that contacts a remote), no history rewriting (no amend, rebase, or squash), deterministic behavior, and clear diagnostics. The exception is justified by isolating Git use to a single, well-defined developer-only module and by making the constraints normative in this SDD.

The intended users are developers and automation (including AI agents) working inside a BusDK module repository. The document’s purpose is to serve as the single source of truth for implementation and review; the audience includes human reviewers and implementation agents.

Out of scope for this SDD: implementing accounting logic, modifying workspace datasets, providing end-user CLI commands for bookkeeping, and any workflow that pushes to or pulls from a remote.

### Goals

G-DEV-001 Centralize developer workflow logic. Replace per-repo scripts with a single `bus dev` command set so behavior and prompts are consistent and maintainable in one place.

G-DEV-002 Developer-only, repository-scoped operations. All operations run in the context of the current working directory as a Git repository and affect only source code, agent instructions (AGENTS.md), and developer artifacts — never workspace datasets or end-user data.

G-DEV-003 Safety and determinism. No remote Git operations, no history rewriting, and deterministic output and exit codes so scripts and CI can rely on `bus dev` behavior.

G-DEV-004 Agent-friendly integration via bus-agent. Subcommands that invoke an external agent runtime use embedded prompts (owned by bus-dev) and depend on the bus-agent Go library for execution. The tool exposes consistent defaults for model and timeout and a well-defined contract for stdout/stderr and exit codes by using bus-agent’s runner, templating, and backend support; at least Cursor CLI, Codex, Gemini CLI, and Claude CLI are supported as selectable options through bus-agent.

G-DEV-005 Deterministic module root initialization. A single subcommand (`bus dev init [DIR]`) MUST initialize a module root in the current working directory by default, or in an explicitly provided target directory when `DIR` is given, without performing any Git operations. By default it initializes directory structure and baseline files only (including a single [AGENTS.md](https://agents.md/) at the project root and a root `Makefile` from an embedded sample when missing). Workflow operations (`plan`, `spec`, `work`, `e2e`) run only when the user explicitly appends them in any order or combination (for example `bus dev init plan spec work` or `bus dev init DIR work plan e2e`), and they execute in the exact order provided. Init is not required to obtain AGENTS.md: `bus dev spec` creates it from online SDD and module end-user documentation when the file is missing (FR-DEV-008), so a repository may get AGENTS.md by running spec without having run init.

### Non-goals

NG-DEV-001 Bus Dev does not perform remote Git operations. Push, pull, fetch, clone, submodule update/init that contacts a remote, or any operation that could contact a remote is out of scope and must never be implemented.

NG-DEV-002 Bus Dev does not rewrite history. Amend, rebase, squash, or any operation that changes existing commit SHAs is out of scope.

NG-DEV-003 Bus Dev does not operate on workspace accounting datasets. Reading or writing workspace CSV, schemas, or datapackage.json for bookkeeping purposes is out of scope; that remains the domain of other BusDK modules.

NG-DEV-004 Bus Dev does not replace the bus dispatcher or module discovery. It is one module among many; the dispatcher continues to route `bus dev …` to the `bus-dev` binary.

NG-DEV-005 Bus Dev must never modify user-global Gemini configuration or memory. Any file under the user’s home Gemini config directory (e.g. `~/.gemini/`), including `~/.gemini/GEMINI.md`, and any global memory managed via interactive Gemini CLI commands (e.g. `/memory add`) are strictly off limits. Bus Dev may read global context only insofar as the Gemini CLI loads it by default when it runs; Bus Dev itself does not write, create, or edit anything outside the current repository. Developers who want global Gemini memory or user-level Gemini config must manage it manually outside Bus Dev.

### Requirements

FR-DEV-001 CLI integration and naming. The binary MUST be named `bus-dev` and MUST be invoked through the dispatcher as `bus dev <operation> [args]`. Acceptance criteria: the dispatcher routes `bus dev init`, `bus dev commit`, `bus dev stage`, `bus dev plan`, `bus dev work`, `bus dev spec`, and `bus dev e2e` to the same binary; when multiple operations (plan, spec, work, e2e, stage, commit) are passed in any order or combination (e.g. `bus dev plan spec work` or `bus dev plan work stage commit`), the binary receives all of them as positional arguments and executes them in the order given.

FR-DEV-001a Multiple workflow operations. The CLI MUST accept one or more consecutive operation names from the set {plan, spec, work, e2e, stage, commit} in a single invocation, in any order and any combination (including repeating an operation, e.g. `bus dev plan work stage commit plan work stage commit`). When two or more of these operations are given, the tool MUST execute them in the order given, one at a time, in the same process and effective working directory. If an operation exits non-zero, the run MUST stop immediately and the tool MUST exit with that operation’s exit code; subsequent operations in the list MUST NOT run. The **stage** operation invokes the agent to prepare the working tree (see FR-DEV-006a), then stages remaining changes so that **commit** can be combined with workflow operations in one invocation without a manual staging step. When **init** is used, only operations from the set {plan, spec, work, e2e} MAY follow init (stage and commit are not accepted after init). Acceptance criteria: `bus dev plan spec work` and `bus dev plan work stage commit` and `bus dev plan work stage commit plan work stage commit` run the listed operations in the order given; if one fails, the run stops with that exit code; `bus dev init [DIR] plan spec work e2e` runs init first, then the workflow operations in the order provided; stage and commit are combinable with plan, spec, work, and e2e in the same invocation.

FR-DEV-002 Repository discovery. For operations that require a repository context (commit, stage, plan, work, spec, e2e when run standalone), the tool MUST determine the current working repository from the effective working directory (after applying `-C`/`--chdir` if present). It MUST NOT require configuration files or environment variables to locate the repo. Acceptance criteria: when run from inside a Git repository root or any subdirectory, the tool uses that repository as the scope for repository-scoped operations; when the effective working directory is not a Git repository, repository-scoped operations exit with a clear diagnostic and a non-zero exit code, while `init` remains valid because it operates on directory initialization rather than repository discovery.

FR-DEV-003 Module identity for spec and e2e. When a repository-scoped subcommand needs the current module name (e.g. for docs URLs or e2e script naming), the tool MUST derive it deterministically from the repository. The module name is the base name of the repository root directory (the last path component of the absolute path to the repo root). For `init`, which may run without a repository, the module name is derived from the base name of the resolved target directory. Acceptance criteria: the same repository always yields the same module name for repository-scoped operations; the same init target path always yields the same module name for initialization; no other derivation rule (e.g. canonical file) is used.

FR-DEV-004 Embedded prompts. All prompts used to drive agent runs MUST be embedded as Go string constants or templates inside the bus-dev binary. The tool MUST NOT load prompts from external prompt files on disk. Acceptance criteria: a fresh clone of the bus-dev repo builds a binary that runs all subcommands without requiring any external prompt files; prompts may still be overridden or extended by flags or environment variables when explicitly documented.

FR-DEV-004a Prompt-template rendering contract. Embedded prompts that use placeholders MUST use the {% raw %}`{{VARIABLE}}`{% endraw %} syntax. Bus-dev MUST use the bus-agent library’s template renderer (or a contract-compatible implementation) so that rendering is deterministic and satisfies the same strict guarantees as bus-agent’s FR-AGT-006: missing or unresolved placeholders MUST cause the command to fail before any agent invocation, with a clear diagnostic and exit code 2. Rendering a template with no placeholders is a pass-through. This contract is part of the determinism and safety guarantees (NFR-DEV-001, NFR-DEV-005): the tool MUST NOT invoke an agent with partially substituted or ambiguous prompt text. Acceptance criteria: unit tests cover missing variable, unresolved variable, repeated placeholder replacement, and expected placeholder set per prompt template; the agent is never invoked when substitution fails.

FR-DEV-004b Configurable docs base URL. The documentation base URL used to derive links in prompts and diagnostics MUST be configurable via the environment variable `BUS_DEV_DOCS_BASE_URL`. The default MUST be `https://docs.busdk.com`. The value MUST be normalized by trimming any trailing slash before use. This value is used to derive documentation links (including the main SDD URL and module-specific SDD and module-docs URLs) that appear in embedded prompts and in diagnostics. The main SDD URL is a first-class derived value: `MAIN_SDD_URL = <DOCS_BASE_URL>/sdd`. The module SDD URL is `<DOCS_BASE_URL>/sdd/<module>` and the module docs URL is `<DOCS_BASE_URL>/modules/<module>`, where `<module>` is the module name (base name of the repository root directory, per FR-DEV-003). Acceptance criteria: when unset, derived URLs use the default base; when set, they use the normalized value; trailing slash is removed; tests verify override effects on derived URLs.

FR-DEV-005 Dependence on bus-agent for agent execution. The implementation MUST depend on the bus-agent Go library for invoking the configured external agent runtime. Bus-dev MUST use bus-agent’s runner interface, template renderer, runtime detection, and installation references rather than reimplementing them. Model, output format, and timeout remain configurable via flags or environment variables; resolution order for these options MUST follow the same logic as agent selection (see Run-config resolution in Component Design). Defaults are documented and deterministic. Acceptance criteria: bus-dev imports and uses the bus-agent package for all agent invocations; model, output format, and timeout are configurable via flags or environment; the integration is testable in isolation (e.g. by stubbing or mocking the bus-agent dependency or the executable in PATH as supported by bus-agent).

FR-DEV-005a Supported agent runtimes via bus-agent. The implementation MUST use bus-agent’s supported runtimes (Cursor CLI, Codex, Gemini CLI, Claude CLI). Bus-dev MUST NOT implement its own agent backends; it MUST delegate to the bus-agent library for backend selection and execution. The active runtime MUST be selectable via a documented flag or environment variable (e.g. `--agent cursor|codex|gemini|claude` or equivalent) that bus-dev passes through to bus-agent’s selection resolution. Acceptance criteria: the user can select any of the four runtimes; switching runtime does not change subcommand semantics or embedded prompts; bus-agent’s backends and installation references are the single source of truth; documentation lists all runtimes and selection mechanism and references the bus-agent SDD where appropriate.

FR-DEV-005b Agent selection configuration. The implementation MUST expose configuration so that the user can choose which agent runtime to use, and that choice MUST be easy to change both per command and for the session. Bus-dev MUST invoke the bus-agent library with caller context so that resolution follows the bus-dev order (FR-AGT-005): (1) per-command override (`--agent <runtime>`), (2) `BUS_DEV_AGENT` (bus-dev only), (3) `BUS_AGENT`, (4) bus-dev persistent preference (e.g. `bus-dev.agent` read via [bus-preferences](./bus-preferences)), (5) bus-agent persistent preference (`bus-agent.runtime`), (6) first available runtime in the effective order. At any step, if the indicated runtime is disabled by user configuration, bus-agent prints a warning and resolution continues with the next source (FR-AGT-005b). The user sets bus-dev's persistent default with `bus preferences set bus-dev.agent <runtime>` and the shared default with `bus preferences set bus-agent.runtime <runtime>`. Acceptance criteria: the user can set a session default via `BUS_DEV_AGENT` or `BUS_AGENT` and run multiple `bus dev` commands without re-specifying; the user can override for a single command with `--agent`; the resolution order is documented; invalid runtime names yield a clear usage error (exit 2); when a configured runtime is disabled, a warning is printed and the next source is used.

FR-DEV-005d Agent detection and automatic default. The implementation MUST use bus-agent’s runtime detection and automatic-default selection rather than implementing its own. When no per-command flag, no session-stored preference, and (if supported) no persistent preference specify a runtime, bus-dev MUST call bus-agent’s resolution so that the automatic default is chosen from available runtimes in bus-agent’s documented order (alphabetic by runtime ID when no user order is configured; see bus-agent FR-AGT-005, FR-AGT-005a). Bus-dev MUST pass through to bus-agent any user-configured agent order and enable/disable settings so that the available set and selection order match bus-agent’s contract. If no agent is available, the tool MUST exit with a clear diagnostic and non-zero exit code and MUST direct the user to install or enable at least one supported agent using the installation references provided by the bus-agent library. Acceptance criteria: running `bus dev work` with no `--agent` and no `BUS_DEV_AGENT` results in bus-agent selecting an available agent when at least one is available; when none is available, the tool exits with a clear message and does not proceed; tests can verify behavior by controlling PATH or by using bus-agent’s testability guarantees (stub executables, hermetic tests).

FR-DEV-005e Agent and model disclosure on each step. When the tool executes an agent-invoking step (plan, work, spec, e2e, or stage), it MUST print to stderr, at the start of that step and before streaming or capturing agent output, which internal agent runtime and which model are in use.

FR-DEV-005f Set agent subcommand. The implementation MUST provide a subcommand `bus dev set agent <runtime>` that writes the bus-dev persistent default agent (e.g. `bus-dev.agent`) via the [bus-preferences](./bus-preferences) Go library. The implementation MUST use the library directly and MUST NOT shell out to the `bus preferences` CLI. Acceptance criteria: running `bus dev set agent gemini` persists the preference; a subsequent `bus dev work` (with no `--agent`, no BUS_DEV_AGENT, no BUS_AGENT) uses that default when resolution reaches the bus-dev preference step; invalid runtime yields exit 2.

FR-DEV-005g Set run-config subcommands (bus-dev namespace only). The implementation MUST provide subcommands `bus dev set model <value>`, `bus dev set output-format <ndjson|text>`, and `bus dev set timeout <duration>` that write **only** the bus-dev preference keys `bus-dev.model`, `bus-dev.output_format`, and `bus-dev.timeout` respectively via the [bus-preferences](./bus-preferences) Go library. The implementation MUST use the library directly and MUST NOT shell out to the `bus preferences` or `bus agent` CLI. Bus-dev MUST NOT write to any other namespace (e.g. `bus-agent.*`); when the user runs `bus dev set model`, `bus dev set output-format`, or `bus dev set timeout`, only the corresponding `bus-dev.*` key is written. Valid values for output-format are `ndjson` and `text`. Invalid value for any subcommand MUST yield exit 2. Acceptance criteria: each subcommand persists only the corresponding bus-dev key; a subsequent agent-invoking command uses the new value when resolution reaches the bus-dev preference step; invalid value yields exit 2; no bus-agent namespace key is ever written by bus-dev.

FR-DEV-005c Gemini integration is repository-local only. When the selected agent runtime is Gemini CLI, Bus Dev MUST create, edit, and rely only on repository-scoped files: a repo-root `GEMINI.md`, optional directory-scoped `GEMINI.md` files, `.gemini/settings.json` (for context discovery, ignore behavior, tool policy, and MCP configuration), and `.geminiignore` (for excluding files from context ingestion). Bus Dev MUST NOT modify any user-global Gemini configuration or memory (see NG-DEV-005). Acceptance criteria: no code path writes to `~/.gemini/` or any path outside the current repository; documentation describes the repo-local Gemini files and their roles; tests verify that the tool never invokes Gemini CLI in a way that would add or change global memory (e.g. no `/memory add` or equivalent).

FR-DEV-006 Commit subcommand behavior. The `bus dev commit` subcommand MUST implement behavior equivalent to the normative commit workflow specified in the Command Surface section below, including: do nothing and exit success when there is nothing staged (or working tree clean in the staged-set sense); operate strictly on the Git index; no file modification, no staging, no amend/rebase, no remote operations; depth-first submodule commits when submodules have staged changes; clear report and stop when a submodule commit causes an unstaged gitlink in the superproject; and enforce the commit message quality rules, atomicity guidance, and failure/hook handling rules as normative requirements. Acceptance criteria: the SDD defines these rules; the implementation enforces them; tests verify behavior with a fixture repo (including submodules when applicable).

FR-DEV-006a Stage subcommand behavior. The `bus dev stage` subcommand MUST prepare the working tree so that only intended files are staged. The tool MUST invoke the configured agent runtime with an embedded prompt that instructs the agent to: (1) review the working tree and identify files that should not be tracked by Git (for example temporary files, e2e test leftovers, build artifacts, or other files that do not belong in version control); (2) for each such file or pattern, either add it (or a matching pattern) to `.gitignore` so it is not staged, or remove the file from the project if it is purely temporary and should not exist in the working tree; (3) leave the working tree in a state where only intended, trackable changes remain. After the agent has completed successfully, the tool MUST stage all remaining changes at the repository root (e.g. the equivalent of `git add .` from the resolved repository root). The tool MUST NOT commit, amend, rebase, or perform any remote Git operation. Only the working tree of the current repository is in scope; the tool MUST NOT recursively stage inside submodules. Acceptance criteria: the stage subcommand invokes the agent with the embedded stage prompt; the agent may update `.gitignore` and may remove temporary files; after the agent exits successfully, the tool runs local `git add` to stage remaining changes; no remote operations; tests verify behavior with a fixture repo (including stubbed agent when hermetic tests are required).

FR-DEV-007 Work subcommand behavior. The `bus dev work` subcommand MUST implement the canonical "do the work in this repo now" agent-runner workflow equivalent to the provided work script: operate only inside the current module repository, follow the module’s AGENTS.md and design docs, implement concrete code changes, add tests, run the Makefile checks, and update README.md before finishing. The agent MUST be allowed to read the repository’s own docs and AGENTS.md as the authoritative specs for that repo. When `PLAN.md` exists at repository root, the embedded work prompt MUST instruct the agent to read it first and prioritize unchecked items in `PLAN.md` before proposing or executing additional work. When work completes an item from `PLAN.md`, the workflow MUST check off that item in `PLAN.md` (for example as `- [x]`). `bus dev work` MUST NOT remove already checked items from `PLAN.md`; pruning completed checked items is owned by `bus dev plan` (FR-DEV-011). When the selected runtime is Gemini CLI, the agent MUST also be able to use repository-local Gemini context (e.g. repo-root and directory-scoped `GEMINI.md`, `.gemini/settings.json`, `.geminiignore`) as documented in the Gemini CLI integration subsection; Bus Dev supports AGENTS.md and Gemini context in parallel without changing core workflow contracts. In headless or script mode, the workflow MUST remain non-interactive and MUST NOT perform prohibited actions (especially network operations); see Headless and script mode below. Acceptance criteria: the workflow is driven by an embedded prompt template; no external prompt file is required; when `PLAN.md` exists the prompt consumes it before other task discovery; completed plan items are checked off by work; checked plan items are never removed by work; behavior is documented and testable via a stubbed agent; headless invocation does not trigger interactive or network operations.

FR-DEV-008 Spec subcommand behavior. The `bus dev spec` subcommand MUST refine only the current repository’s AGENTS.md and nothing else. The tool MUST use the path `AGENTS.md` at the repository root (no module-derived path). The file is the single, open-format agent-instruction file per the [AGENTS.md](https://agents.md/) convention. If AGENTS.md does not exist, the tool MUST create it before refining: the embedded spec prompt MUST instruct the agent to produce an initial AGENTS.md from the online BusDK SDD (main SDD, module SDD, module end-user documentation) and related documents, so that the resulting file is a compact but detailed local spec describing how to implement this tool. If AGENTS.md already exists, the tool MUST run an embedded refinement prompt that instructs the agent to update only that file and to align it with the latest BusDK specs and the AGENTS.md format. In both cases the agent MUST use the documentation URLs derived from the docs base URL and prompt variables (e.g. `MAIN_SDD_URL`, `MODULE_SDD_URL`, `MODULE_DOCS_URL`). The written AGENTS.md MUST be a compact but detailed local spec for implementing the current module — grounded in the module’s SDD and end-user docs, not a generic template. Acceptance criteria: no refinement of source code, tests, or README; the path is always repository-root `AGENTS.md`; when AGENTS.md is missing it is created from online docs then refined in the same run; when it exists it is refined in place; created or refined content is module-specific implementation guidance.
FR-DEV-008a Cursor rules refactor. When running `bus dev spec`, if a Cursor rule file exists at `.cursor/rules/<MODULE_NAME>.mdc` (where `<MODULE_NAME>` is the module name per FR-DEV-003, e.g. `bus-accounts`), the tool MUST include that file’s content in the refinement context. The embedded spec prompt MUST instruct the agent to refactor the substantive content from that Cursor rule into AGENTS.md so that agent instructions are consolidated in AGENTS.md. After the agent has written the updated AGENTS.md, the tool MUST remove the file `.cursor/rules/<MODULE_NAME>.mdc`. This is the only permitted case where bus-dev (or the shared instruction contract used by bus-agent) may replace or remove existing repo content for instruction standardization; all other repo-local file changes MUST be additive only per NFR-DEV-008. If `.cursor/rules/<MODULE_NAME>.mdc` does not exist, no Cursor rule file is read or deleted. Acceptance criteria: when the Cursor rule file exists, its content is merged into AGENTS.md and the file is deleted; when it does not exist, spec behavior is unchanged; no other files under `.cursor/rules/` are modified; the MDC exception is documented and testable.

FR-DEV-009 E2E subcommand behavior. The `bus dev e2e` subcommand MUST provide a guided workflow to detect missing end-to-end tests for the current module repository and scaffold them in a hermetic way, consistent with BusDK testing conventions and the module’s SDD and end-user documentation. E2E tests are Bash shell scripts that run the module’s compiled binary; they MUST live under the `tests/` directory and MUST be named `e2e_bus_<name>.sh` where `<name>` is the module name with the `bus-` prefix stripped (e.g. module `bus-accounts` → `tests/e2e_bus_accounts.sh`). Each bus module MUST also implement complete unit tests; e2e and unit-test conventions are described in agent instructions (e.g. [AGENTS.md](https://agents.md/)) and agent-specific configuration. The tool MUST use the module’s SDD and end-user documentation to determine which tests are needed and MUST produce scaffolds that cover the behavior described there; language- and module-specific details are defined in agent rules. When `PLAN.md` exists at repository root, the embedded e2e prompt MUST instruct the agent to read it first, verify that each checked item is fully covered by e2e tests, and prioritize unchecked test-related items from the plan before proposing additional test scope. Independently of `PLAN.md`, the command MUST continue discovering other untested behavior required by the module SDD and end-user docs. `bus dev e2e` MUST NOT remove already checked items from `PLAN.md`; pruning completed checked items is owned by `bus dev plan` (FR-DEV-011). Acceptance criteria: the command detects missing e2e tests by consulting the module SDD and end-user docs; when `PLAN.md` exists the prompt consumes it before additional discovery; checked plan items are validated against e2e coverage; other untested documented behavior is still discovered; checked plan items are never removed by e2e; scaffold output uses the `tests/e2e_bus_<name>.sh` layout and naming; scaffold content is deterministic and aligned with those sources and with agent rules; the command has defined preconditions and safety constraints.

FR-DEV-010 Init subcommand behavior. The `bus dev init [DIR] [--lang go] [plan|spec|work|e2e ...]` subcommand MUST initialize module-root files without performing any Git operations, and MUST run workflow operations only when they are explicitly appended after init. Behavior MUST be equivalent to: (1) resolve the target directory as current working directory when `DIR` is omitted, or as `DIR` when provided; (2) if `DIR` is provided and does not exist, create it; if the resolved target path exists but is not a directory, exit with code 2 and a clear error; (3) when init runs, ensure a single `AGENTS.md` exists at the target directory root (project root), with default content that MAY depend on `--lang` per the [AGENTS.md](https://agents.md/) format; (4) ensure a root `Makefile` exists, creating it from an embedded sample Makefile when missing; (5) if one or more workflow operations (plan, spec, work, e2e) are appended after init in any order or combination, set the effective working directory to the target directory and execute those operations exactly in the order provided. The `--lang` flag MUST default to `go` and MUST control which kind of default AGENTS.md content the tool installs for future multi-language support. Init is not a prerequisite for AGENTS.md: repositories may obtain AGENTS.md by running `bus dev spec` when the file is missing (FR-DEV-008), without ever running init. Acceptance criteria: no Git commands are executed; running `bus dev init` initializes only the current directory and does not invoke plan/spec/work/e2e; running `bus dev init DIR` performs the same initialization in DIR; running `bus dev init [DIR] plan spec work e2e` (or any order/combination of plan, spec, work, e2e) runs all listed operations in that exact order and stops on first failure; initialization creates missing scaffold files and does not overwrite an existing `Makefile` by default; tests verify both default init-only behavior and ordered optional workflow execution.

FR-DEV-011 Plan subcommand behavior. The `bus dev plan` subcommand MUST review online documentation and current repository content to produce a compact task plan in `PLAN.md` at repository root. The required documentation inputs are: the main SDD URL (`MAIN_SDD_URL`), the current module SDD URL (`MODULE_SDD_URL`), the current module end-user docs URL (`MODULE_DOCS_URL`), and any project SDD pages directly relevant to requirements found in those pages. The command MUST detect unimplemented features and other undone work by comparing documented requirements and expected behavior to the current repository. If `PLAN.md` already exists, the command MUST re-validate existing items against current repository state and current documentation, remove items that are already done (including previously checked items), retain items that are still undone, and then add any newly detected missing work. The command MUST write only `PLAN.md` and MUST NOT modify source files, tests, or other docs. `PLAN.md` content written by `bus dev plan` MUST be a compact unchecked Markdown task list, with one unchecked item per still-undone or newly detected unimplemented feature or undone work item, ordered from highest to lowest priority. Each item MUST be short and action-oriented, with enough context for an agent to choose the next task, and MUST avoid implementation details that belong in the project SDD and related docs. Acceptance criteria: `bus dev plan` creates or overwrites `PLAN.md` deterministically for the same repository and docs inputs; when `PLAN.md` existed before the run, completed items (including checked ones) are removed and still-valid undone items are preserved or rephrased compactly; newly detected missing work is appended into the same prioritized list; every listed item is unchecked (`- [ ]`); list ordering reflects priority; no implementation-level steps are included; no files other than `PLAN.md` are changed.

FR-DEV-012 Working-directory lock. At most one `bus dev` invocation that operates on a given directory MAY run at a time. For subcommands that read or modify the effective operation directory (init, commit, stage, plan, work, spec, e2e), the tool MUST acquire an exclusive lock on that directory before performing any subcommand work and MUST release the lock when the process exits, whether the exit is normal or abnormal. A second invocation that targets the same effective operation directory MUST block until the first invocation releases the lock, then acquire the lock and proceed. Subcommands that only write preferences (e.g. `bus dev set agent`, `bus dev set model`, `bus dev set output-format`, `bus dev set timeout`) do not require the lock because they do not touch the working directory. The lock scope is the effective operation directory: for `bus dev init [DIR]` it is the resolved init target directory (effective working directory when DIR is omitted, or DIR when provided); for commit, stage, plan, work, spec, and e2e it is the repository root derived from the effective working directory. Acceptance criteria: two concurrent `bus dev work` (or plan, spec, e2e, stage, commit, or init targeting the same directory) run one after the other; the second blocks until the first exits; the lock is released on success, on failure, and on interrupt; `bus dev set …` does not participate in locking; tests can verify serialization and lock release.

NFR-DEV-001 Determinism. Output and exit codes MUST be deterministic for the same inputs and repository state. Acceptance criteria: repeated runs with the same staged set and same repo state yield the same exit code and consistent diagnostics.

NFR-DEV-002 No remote operations. The implementation MUST NOT perform any Git operation that contacts a remote. Acceptance criteria: no code path may call push, pull, fetch, clone, or submodule update/init in a way that touches a remote; tests and code review can verify this.

NFR-DEV-003 Hermetic tests. Tests MUST be hermetic: no network, no real external services, no reliance on a real agent runtime (e.g. Cursor CLI, Codex, Gemini CLI, or Claude CLI) or remote. Acceptance criteria: unit tests and fixture-based tests run in CI without network; agent invocation is tested by stubbing the agent binary in PATH and feeding deterministic NDJSON or output to exercise parsing, filtering, and error handling.

NFR-DEV-004 Cross-platform. Behavior and tests MUST be defined so they can run on Linux and macOS in line with the project’s CI. Acceptance criteria: no OS-specific assumptions are left unspecified; where behavior differs by platform, it is documented.

NFR-DEV-005 Security. The tool MUST NOT execute arbitrary code from repository content. The only permitted external execution is: the configured agent runtime (with embedded prompts) and local `git` for the commit and stage workflows (NFR-DEV-002 covers the no-remote constraint). Acceptance criteria: no execution of repository-provided scripts or binaries; agent and Git usage are the only defined execution boundaries.

NFR-DEV-006 Maintainability. The bus-agent integration and subcommand handlers MUST be testable in isolation with stubbed dependencies (e.g. stub agent in PATH as supported by bus-agent, fixture repositories). Prompts and derivation rules MUST be documented in this SDD so that behavior can be verified without reading source. Acceptance criteria: unit tests cover repo resolution, flag parsing, and subcommand flow with bus-agent stubbed or stub executable in PATH; design docs are the single source of truth for derivation and command semantics.

NFR-DEV-007 No user configuration outside project. Bus-dev MUST NOT edit any user configuration outside the project working directory (the repository or init target directory). Bus-dev MAY set environment variables and command-line options for the child agent process; it MUST NOT create, modify, or delete files outside the project working directory for configuration or instruction discovery. This aligns with the same constraint in [bus-agent](./bus-agent) (NFR-AGT-005). Acceptance criteria: no code path writes to paths outside the effective project workdir for config or instruction setup; tests verify workdir-scoped behavior.

NFR-DEV-008 Additive-only repo file changes. When bus-dev creates or modifies files inside the repository to enable instruction discovery or runtime adapter support (e.g. Gemini repo-local files, Cursor rules), changes MUST be additive only: existing user content MUST NOT be removed or rewritten. The only permitted exception is the legacy Cursor rule file at `.cursor/rules/<MODULE_NAME>.mdc` (module name per FR-DEV-003), which MAY be replaced or migrated as part of standardizing on AGENTS.md (see FR-DEV-008a). Any other repo-local file creation or merge MUST use append-only Bus-owned blocks with explicit markers. This aligns with [bus-agent](./bus-agent) NFR-AGT-006 and FR-AGT-014. Acceptance criteria: repo-local file creation or merge uses append-only Bus-owned blocks with clear markers; existing user content is never deleted or overwritten except for the documented .cursor/rules/<MODULE_NAME>.mdc exception; behavior is testable.

Bus-dev uses the same instruction model as bus-agent for its developer workflows (commit, work, spec, e2e): AGENTS.md at the repository root is the canonical, vendor-neutral instruction source; per-runtime adapters (Codex, Cursor, Gemini CLI, Claude Code) follow the contract defined in the bus-agent SDD ("Project instructions (AGENTS.md) and per-runtime adapters"), so the agent instruction contract is shared across modules and can be implemented and tested consistently.

### System Architecture

Bus Dev is a thin CLI that delegates to testable packages. The main entrypoint is `Run(args, workdir, stdout, stderr) int`; the `main` package calls it and exits with its return value. No `os.Exit` is used outside `main`, so behavior is testable without process exit.

High-level components:

- **CLI layer.** Parses global flags (including BusDK-standard `-C`, `-o`, `-v`, `-q`, `--help`, `--version`) and the `bus dev` operation(s), resolves the effective working directory, and resolves the agent runtime selection: per-command flag overrides session-stored preference; when neither is set, the implementation delegates to bus-agent for the automatic default from available runtimes in bus-agent’s order (alphabetic when no user order is configured; user can configure order and enable/disable per bus-agent FR-AGT-005a) (FR-DEV-005b, FR-DEV-005d). For subcommands that operate on a directory (init, commit, stage, plan, work, spec, e2e), the CLI acquires an exclusive working-directory lock on the effective operation directory before running any handler and releases it when the process exits; a concurrent invocation for the same directory blocks until the lock is available (FR-DEV-012). When an agent step runs, the tool prints to stderr which agent and model are in use (FR-DEV-005e). When multiple workflow operations (plan, spec, work, e2e) are given in any order or combination, it runs them in the order given, delegating to each handler in sequence and stopping on first failure (FR-DEV-001a); otherwise it delegates to the single operation’s handler.

- **Repository and module resolution.** A small package (or internal function set) that, given a workdir, detects whether it is inside a Git repository, finds the repository root, and derives the module name when needed (e.g. for `bus dev plan`, `bus dev spec`, and `bus dev e2e`). The module name is the base name of the repository root directory (FR-DEV-003). This layer does not perform any Git write operations; it only reads repository metadata.

- **bus-agent library dependency.** Bus Dev does not implement an agent runner itself. It depends on the [bus-agent](./bus-agent) Go library for runtime selection, prompt-template rendering, command construction, timeout enforcement, and output capture or streaming. Subcommand handlers (plan, work, spec, e2e) pass workflow-specific prompt content and variables to bus-agent, which invokes the configured external agent (Cursor CLI, Codex, Gemini CLI, or Claude CLI) in the given workdir. Bus Dev supports both AGENTS.md and Gemini context in parallel: workflow contracts do not change based on which backend is selected; the agent reads the repo’s Cursor rules and, when Gemini CLI is selected, the repo’s repository-local Gemini context as documented in the Gemini CLI integration subsection. In headless or script mode, bus-dev invokes bus-agent in a way that keeps workflows non-interactive and prevents prohibited actions (especially network operations); bus-agent’s script-safe contract supports this.

- **Subcommand handlers.** One logical component per operation: init, commit, stage, plan, work, spec, e2e. Each handler receives parsed flags, the resolved workdir (and repo root and module name when relevant), and stdout/stderr writers, and returns an exit code. When the user invokes multiple workflow operations in any order or combination (e.g. `bus dev plan spec work`, `bus dev work plan`, or `bus dev init [DIR] plan work e2e`), the CLI layer invokes each handler in the order given and stops on first non-zero exit (FR-DEV-001a). Init resolves the target directory (current directory by default), creates missing scaffold files (repository-root `AGENTS.md` and root `Makefile` from an embedded sample if missing), and by default does not invoke agent workflows; it invokes plan/spec/work/e2e only when those operations are explicitly present after init (stage and commit are not accepted after init). The plan handler derives documentation URLs, reads existing `PLAN.md` when present, drives the embedded planning prompt via bus-agent to re-validate prior items and discover new missing work, prunes completed checked items, and enforces that only repository-root `PLAN.md` is written. The spec handler creates repository-root `AGENTS.md` from online SDD and user docs when missing, then refines it (or refines it in place when it exists); when `.cursor/rules/<MODULE_NAME>.mdc` exists, the handler includes its content in the refinement context and removes that file after the agent has merged it into AGENTS.md (FR-DEV-008, FR-DEV-008a). The work handler checks off completed plan items but does not delete checked items. The e2e handler validates checked plan items against e2e coverage and does not delete checked items. The stage handler invokes the agent with the embedded stage prompt (FR-DEV-006a); after the agent completes successfully, the handler stages all remaining changes at the repository root (e.g. `git add .`). Commit may use Git only for read operations plus `git commit` with already-staged content; it must not stage, amend, or touch remotes.

- **Embedded prompts.** Prompts for commit, plan, work, spec, stage, and (when applicable) e2e are compiled into the binary as string constants or templates. Templates use {% raw %}`{{VARIABLE}}`{% endraw %} placeholders; variables are derived at runtime from the repository resolution layer and the docs base URL (see Prompt variable catalog and FR-DEV-004a). Bus-dev uses the bus-agent library for template rendering (or a contract-compatible implementation) so that rendering is deterministic and fails fast on missing or unresolved placeholders before any agent invocation. No prompts are loaded from the filesystem.

- **Log formatting (optional).** The NDJSON-to-text style formatter (equivalent to the provided format-cursor-log / ndjson-to-text behavior) may be provided by the bus-agent library or implemented locally when bus-dev streams agent output to stderr. The SDD treats this as the desired direction; whether it is a separate subcommand or only internal is left as an implementation detail, with the initial scope kept minimal and deterministic.

Data flow: user invokes `bus dev <subcommand>`; dispatcher runs `bus-dev <subcommand> [args]`; CLI parses args and workdir; repo resolution checks Git repo and optionally module name; subcommand handler runs (Git for commit; agent then Git for stage; agent for plan/work/spec/e2e, or scaffold/detect for e2e). When an agent is used, the handler supplies embedded prompt template and variables to the bus-agent library, which renders the prompt and invokes the selected external agent; output is captured or streamed per bus-agent’s contract. All diagnostics to stderr, deterministic result/exit code.

### Key Decisions

KD-DEV-001 Git exception scoped to bus-dev. BusDK’s NG-001 (no Git execution) is relaxed only for the bus-dev module, and only for local, non-remote, non-rewriting operations, to support developer workflows without embedding Git logic in every other module.

KD-DEV-002 Prompts embedded in binary. Prompts are not loaded from the repository or from external files so that behavior is versioned with the binary and consistent across all module repos that use the same bus-dev version.

KD-DEV-003 Agent execution via bus-agent. The tool does not implement its own agent runner; it depends on the bus-agent Go library to invoke external agent runtimes. This keeps bus-dev focused on workflow semantics and prompts while bus-agent owns the runner abstraction, backends, and execution contract.

KD-DEV-004 Modular agent backends from bus-agent. Cursor CLI, Codex, Gemini CLI, and Claude CLI are supported as selectable backends through the bus-agent library. Bus-dev passes the user’s selection (or automatic default) to bus-agent, which provides the backend abstraction and preference order (FR-DEV-005d). Adding or changing runtimes is done in bus-agent; bus-dev’s subcommand semantics and embedded prompts do not change.

KD-DEV-005 Thin CLI, testable core. The CLI parses arguments and delegates to packages that take workdir and I/O writers; `Run(...) int` allows full unit and integration tests without spawning processes or calling `os.Exit`.

KD-DEV-006 E2E test convention. Bus module e2e tests are Bash scripts under `tests/` named `e2e_bus_<name>.sh`, running the compiled binary. Detection of missing tests and scaffold content are driven by the module’s SDD and end-user documentation; agent instructions (e.g. [AGENTS.md](https://agents.md/)) define language and module-specific testing expectations. Modules also implement full unit tests in addition to e2e.

KD-DEV-007 Single-instance per directory via file lock. To prevent two `bus dev` invocations from running concurrently on the same working directory (which would risk conflicting edits to PLAN.md, AGENTS.md, staging, and agent context), the tool acquires an exclusive lock on the effective operation directory and blocks a second invocation until the first exits. Locking is implemented with a lock file and exclusive file lock (e.g. flock) so behavior is deterministic and script-friendly: the next command waits rather than failing. The `set` subcommands are excluded because they only write preferences and do not touch the directory.

### Component Design and Interfaces

Interface IF-DEV-001 (dispatcher). The `bus` dispatcher invokes the `bus-dev` binary with the remaining arguments after `dev`: global flags and one or more operation names. For `bus dev init [DIR]`, the first positional after flags is `init`; the next positional is optional and, when present and not one of `plan|spec|work|e2e`, is treated as the target directory; any following operation tokens from `plan|spec|work|e2e` are executed in the order given (stage and commit are not accepted after init). For a single operation, e.g. `bus dev plan`, `bus dev work`, `bus dev stage`, or `bus dev commit`, the binary runs that operation. For multiple operations (e.g. `bus dev plan spec work`, `bus dev plan work stage commit`, or `bus dev plan work stage commit plan work stage commit`), the binary receives those operation names in the order given and executes them in sequence (FR-DEV-001a). Standard global flags (`-C`, `-o`, `-v`, `-q`, `--help`, `--version`, etc.) follow BusDK CLI conventions. An agent selection flag (e.g. `--agent <runtime>`) and the session-stored preference (e.g. `BUS_DEV_AGENT`) are resolved as per FR-DEV-005b; see traceability links.

Interface IF-DEV-002 (Run entrypoint). The program exposes a single entrypoint `Run(args []string, workdir string, stdout, stderr io.Writer) int`. `main` passes `os.Args[1:]`, the effective working directory (from `-C` or current process), `os.Stdout`, and `os.Stderr`, and exits with the returned code. No other package calls `os.Exit`.

Interface IF-DEV-003 (bus-agent integration). Bus-dev invokes the bus-agent library’s runner interface (see [bus-agent](./bus-agent) IF-AGT-001) with: selected runtime (or leave resolution to bus-agent), prompt text (after rendering the embedded template with the prompt variable catalog), workdir, timeout, and output mode (capture/stream). Bus-agent returns an exit code and streams or captures output per its contract. Bus-dev does not implement this interface; it is a caller of the bus-agent package. Tests may stub the agent executable in PATH (as supported by bus-agent) or mock the bus-agent dependency to verify bus-dev’s workflow and prompt wiring without running a real agent.

Interface IF-DEV-004 (repo resolution). Given a directory path, the resolver returns: whether the path is inside a Git repository, the repository root path, and (when requested) the module name. For repository-scoped operations, module name MUST be the base name of the repository root directory (see FR-DEV-003). If not inside a repo, the resolver returns an error suitable for a clear user-facing message. `init` target naming is deterministic but does not require repo resolution; it uses the base name of the resolved target directory.

Interface IF-DEV-005 (working-directory lock). For subcommands that operate on a directory (init, commit, stage, plan, work, spec, e2e), the implementation MUST acquire an exclusive lock keyed by the effective operation directory before performing any subcommand work. The lock MUST be implemented so that only one process holds it at a time per directory; a second process attempting to acquire the lock for the same directory MUST block until the first releases it. The lock MUST be released when the process exits (normal exit, non-zero exit, or signal). Lock scope: for `bus dev init [DIR]`, the resolved init target directory; for commit, stage, plan, work, spec, and e2e, the repository root. The `set` subcommands do not acquire the lock. If the lock cannot be acquired (e.g. the directory is not writable or the lock file cannot be created), the tool MUST exit with a clear diagnostic and a non-zero exit code. See FR-DEV-012 and Data Design (lock file).

**Prompt variable catalog.** The following variables are available for substitution in embedded prompt templates (FR-DEV-004, FR-DEV-004a). All are derived at runtime from repository resolution, the configured docs base URL (FR-DEV-004b), or the operation context. Each prompt template documents which of these it uses; substitution MUST be complete before agent invocation (FR-DEV-004a).

| Variable | Description | Source / derivation |
| -------- | ----------- | ------------------- |
| `DOCS_BASE_URL` | Base URL for documentation; used to build all doc links. | `BUS_DEV_DOCS_BASE_URL` env (default `https://docs.busdk.com`), trailing slash trimmed. |
| `MAIN_SDD_URL` | URL of the main BusDK SDD index. | `<DOCS_BASE_URL>/sdd` |
| `MODULE_NAME` | Current module name (e.g. `bus-accounts`). | Base name of repository root directory (FR-DEV-003). |
| `MODULE_SUFFIX` | Module name with `bus-` prefix stripped (e.g. `accounts`). | Derived from `MODULE_NAME`. |
| `MODULE_SDD_URL` | URL of this module’s SDD page. | `<DOCS_BASE_URL>/sdd/<MODULE_NAME>` |
| `MODULE_DOCS_URL` | URL of this module’s end-user docs page. | `<DOCS_BASE_URL>/modules/<MODULE_NAME>` |
| `E2E_SCRIPT` | E2E script filename (e.g. `e2e_bus_accounts.sh`). | `e2e_bus_<MODULE_SUFFIX>.sh` |
| `E2E_SCRIPT_PATH` | Path to the E2E script under the repo (e.g. `tests/e2e_bus_accounts.sh`). | `tests/<E2E_SCRIPT>` |
| `E2E_WORKSPACE_DIR` | Absolute path to the repository root used as e2e workspace. | Resolved repo root. |
| `AGENTS_FILE_PATH` | Path to the repository-root AGENTS.md (e.g. `<repo-root>/AGENTS.md`). | Repository root + `AGENTS.md`. Spec-subcommand prompts only. |
| `PLAN_FILE` | Repository-local planning file used by plan/work/e2e (`PLAN.md`). | Literal value `PLAN.md` at repository root. |
| `PLAN_FILE_PATH` | Absolute path to `PLAN.md` in the current repository. | `<repo-root>/PLAN.md` |

`AGENTS_FILE_PATH` is used only in the spec subcommand’s prompt context. `PLAN_FILE` and `PLAN_FILE_PATH` are used by plan, and are also available to work and e2e so those prompts can read `PLAN.md` when present. The implementation MUST supply the expected placeholder set per template so that missing or unresolved placeholders are detected before agent invocation (FR-DEV-004a).

**Supported agent runtimes and installation references.** The set of supported runtimes (Cursor CLI, Codex, Gemini CLI, Claude CLI), their executable detection, and the canonical installation URLs for diagnostics are defined in the [bus-agent](./bus-agent) SDD (Component Design: Runtime installation references; FR-AGT-003, FR-AGT-010). Bus-dev MUST use the bus-agent library for execution and therefore uses the same runtimes and installation references; bus-dev does not duplicate this table or implement its own backends. When the selected agent is not installed or not in PATH, bus-dev surfaces the failure and installation reference as provided by bus-agent.

**Agent selection configuration.** Resolution order when bus-dev invokes the bus-agent library is (FR-AGT-005, FR-DEV-005b): (1) **Per-command override:** `--agent cursor|codex|gemini|claude` for that invocation only. (2) **BUS_DEV_AGENT:** bus-dev-only session default; when set, used for every `bus dev` command in that session until unset or overridden by `--agent`. (3) **BUS_AGENT:** shared session default; when set and BUS_DEV_AGENT is not, used for bus-dev and for `bus agent` CLI. (4) **bus-dev persistent preference:** e.g. `bus-dev.agent` read via bus-preferences; affects only bus-dev's agent use (e.g. plan, work, spec, e2e). (5) **bus-agent persistent preference:** `bus-agent.runtime` read via bus-preferences. (6) **First available runtime** in the effective order (user-configured order or alphabetical by runtime ID; see bus-agent FR-AGT-005a). At any step, if the indicated runtime is disabled by user configuration, bus-agent prints a warning to stderr and resolution continues with the next source (FR-AGT-005b). Bus-dev MUST invoke bus-agent with caller context so bus-agent consults BUS_DEV_AGENT and bus-dev preference in the correct place. Bus-dev MUST pass through to bus-agent any user-configured agent order and enable/disable settings. Invalid runtime names (e.g. `--agent unknown`) MUST produce a clear usage error and exit 2. If no agent is available when resolution reaches step (6), the tool MUST exit with a clear diagnostic and direct the user to install or enable at least one supported agent (see Error Handling). The executable name(s) used to detect each runtime are defined in the bus-agent SDD (IF-AGT-002). At the start of each agent step (plan, work, spec, e2e), the tool MUST print to stderr which internal agent and model are in use (FR-DEV-005e).

**Run-config resolution (model, timeout, output-format).** For model, output format, and timeout, bus-dev MUST use the same resolution logic and order as for agent, so that each option has a consistent precedence and bus-dev never writes outside the `bus-dev` namespace. When bus-dev invokes the bus-agent library, it MUST resolve run-config in this order: (1) per-command override (e.g. `--model`, `--timeout`, `--output-format` if implemented as flags); (2) bus-dev session environment: `BUS_DEV_MODEL`, `BUS_DEV_TIMEOUT`, `BUS_DEV_OUTPUT_FORMAT` (bus-dev only; when set, used for every `bus dev` command in that session until unset or overridden); (3) bus-dev persistent preference: `bus-dev.model`, `bus-dev.timeout`, `bus-dev.output_format` read via bus-preferences; (4) bus-agent persistent preference: `bus-agent.model`, `bus-agent.timeout`, `bus-agent.output_format` read via bus-preferences (fallback when bus-dev has no value); (5) bus-agent documented default (e.g. `auto` for model, `text` for output_format). The implementation MUST read preferences via the bus-preferences library only; when the user runs `bus dev set model`, `bus dev set output-format`, or `bus dev set timeout`, the implementation MUST write only the corresponding `bus-dev.*` key and MUST NOT write to any key under another namespace (e.g. `bus-agent.*`). This ensures that configuration set through bus-dev affects only bus-dev’s defaults and never changes the bus-agent namespace.

**Gemini CLI integration.** When the user selects Gemini CLI as the agent runtime, Bus Dev supports the same workflow as for Cursor (plan, work, spec, e2e) without changing core workflow contracts. In Gemini terms, project-level agent-instruction configuration means the use of project-level context and settings files that play a role analogous to Cursor’s `.cursor/rules/*.mdc` and project settings: the Gemini CLI loads context from markdown files (by default `GEMINI.md`) and respects a project `.gemini/settings.json` and `.geminiignore`. Instruction loading for Gemini follows the [bus-agent](./bus-agent) per-runtime adapter: AGENTS.md is the canonical instruction source; repo-local `.gemini/settings.json` (e.g. context.fileName to prefer or include AGENTS.md) and `.geminiignore` are used as documented there, with additive-only merges and Bus-owned markers when bus-dev or bus-agent touches those files. Bus Dev documents and, where applicable, creates or updates only the repository-local layer so that both AGENTS.md and Gemini context can be used in parallel for the same repo.

Hard boundary: Bus Dev MUST NOT modify any user-global Gemini configuration or memory. That includes `~/.gemini/GEMINI.md`, any other file under the user’s home Gemini config directory, and any global memory managed via interactive Gemini CLI commands such as `/memory add`. Bus Dev may read global context only if the Gemini CLI loads it by default when the agent is invoked; Bus Dev itself does not write, create, or edit anything outside the current repository (NG-DEV-005, FR-DEV-005c). Developers who want global Gemini memory or user-level Gemini config must manage it manually outside Bus Dev.

Repository-local files that Bus Dev may create, edit, or rely on are: (1) a repo-root `GEMINI.md` that supplies project-level instructions and context for the agent; (2) optional directory-scoped `GEMINI.md` files for subdirectory-specific context; (3) `.gemini/settings.json` for context discovery, ignore behavior, tool policy, and MCP configuration; and (4) `.geminiignore` for excluding files from context ingestion. The intended precedence and scoping model when the Gemini CLI runs is: global user context (loaded by the CLI from `~/.gemini/` and any user-managed memory) is applied first; then repository context from the repo-root `GEMINI.md` and `.gemini/settings.json`; then directory context from any `GEMINI.md` in the current or ancestor directories. Bus Dev’s responsibility is limited to documenting and managing the repository-local layer only; it does not configure or alter the global layer.

Example narrative of repo-local files and responsibilities: The repo-root `GEMINI.md` typically holds project-wide instructions, conventions, and links to design docs so that when `bus dev work` or `bus dev spec` invokes the Gemini CLI, the agent receives consistent project context. Directory-level `GEMINI.md` files (e.g. under `internal/` or `docs/`) can narrow scope for that subtree. The `.gemini/settings.json` file controls how the Gemini CLI discovers context files, which paths to ignore, tool usage policy, and MCP server configuration for that repo. The `.geminiignore` file lists patterns of files or directories to exclude from context ingestion, analogous to `.cursorignore` for Cursor. Bus Dev may scaffold or update these files during `bus dev init` or when documenting the layout; it never touches `~/.gemini/` or global memory.

### Command Surface

**Invocation.** The CLI is invoked as `bus dev [global-flags] <operation> [operation ...]`. Operations are: **init**, **commit**, **stage**, **plan**, **spec**, **work**, **e2e**, **set**. Only one invocation that operates on a given directory (init, commit, stage, plan, work, spec, e2e) runs at a time for that directory; a second invocation for the same directory waits until the first exits (see FR-DEV-012). The operations **plan**, **spec**, **work**, **e2e**, **stage**, and **commit** MAY be combined in one invocation in any order and any combination (including repeating one, e.g. `bus dev plan work stage commit plan work stage commit`); when multiple are given, they run in the order given, one at a time, and the run stops on first failure (see FR-DEV-001a). **stage** invokes the agent to prepare the working tree (identify and ignore or remove unintended files), then stages remaining changes so that **commit** can be used in the same invocation without a manual staging step. `init` accepts an optional target directory and may be followed by zero or more workflow operations from the set {plan, spec, work, e2e} only: `bus dev init [DIR] [plan|spec|work|e2e ...]`. **`set`** is a preference-setting operation (see below) and does not participate in the working-directory lock. Global flags apply as per BusDK CLI conventions. The agent runtime is selected by the resolution order in Agent selection configuration above: `--agent`, then `BUS_DEV_AGENT`, then `BUS_AGENT`, then bus-dev and bus-agent preferences, then first available enabled agent.

**`bus dev set agent <runtime>`**

Intent: Set the bus-dev persistent default agent (e.g. `bus-dev.agent`) via the [bus-preferences](./bus-preferences) Go library so that every `bus dev` command in future sessions uses that runtime when no `--agent`, `BUS_DEV_AGENT`, or `BUS_AGENT` is set. The implementation MUST use the bus-preferences library to write the preference; it MUST NOT shell out to `bus preferences`. `<runtime>` MUST be one of `cursor`, `codex`, `gemini`, or `claude`. Invalid key or value yields exit 2. Success MAY be confirmed by a short message to stderr or by exiting 0 with no required stdout output.

**`bus dev set model <value>`** — Set the bus-dev persistent default model (`bus-dev.model`) via the bus-preferences library. Only the `bus-dev` namespace is written; no other namespace (e.g. `bus-agent`) is modified. Invalid value yields exit 2.

**`bus dev set output-format <ndjson|text>`** — Set the bus-dev persistent default output format (`bus-dev.output_format`) via the bus-preferences library. Valid values: `ndjson`, `text`. Only the `bus-dev` namespace is written. Invalid value yields exit 2.

**`bus dev set timeout <duration>`** — Set the bus-dev persistent default timeout (`bus-dev.timeout`) via the bus-preferences library (e.g. `60m`). Only the `bus-dev` namespace is written. Invalid value yields exit 2.

**Headless and script mode.** When `bus dev` invokes an agent (plan, work, spec, e2e, stage) from a non-interactive environment — for example from a script, CI, or a headless runner — the workflow MUST remain non-interactive and MUST NOT perform prohibited actions. Prohibited actions include network operations (e.g. the agent must not be instructed or allowed to push, pull, fetch, or call external APIs as part of the workflow), modifying user-global configuration or memory (see NG-DEV-005 and Gemini CLI integration), and any operation that would block waiting for user input. The implementation MUST invoke the selected agent with flags or environment that enforce non-interactive, script-safe behavior so that `bus dev plan`, `bus dev work`, `bus dev spec`, `bus dev e2e`, and `bus dev stage` can be used in automation without requiring a TTY or user interaction. Exit codes and stderr output remain deterministic as specified elsewhere in this SDD.

**`bus dev init [DIR] [--lang go] [plan|spec|work|e2e ...]`**

Intent: Initialize a BusDK module root in place, in the current working directory by default or in an explicitly provided target directory, without performing any Git operations. By default, init performs initialization only; it does not run spec, work, or e2e unless those operations are explicitly appended after init.

Preconditions: The effective working directory need not be a Git repository. If `DIR` is omitted, the target directory is the effective current working directory and must exist. If `DIR` is provided and does not exist, init creates it. If the target path exists but is not a directory, the command exits with code 2 and a clear message. Agent runtime availability is required only when appended operations (plan/spec/work/e2e) are requested.

Reads: Existing repository files in the target directory (to detect whether scaffold files are already present), embedded init templates (including the sample Makefile), and BusDK documentation and embedded prompts only when appended operations are run. No workspace datasets.

Writes: Ensures a single `AGENTS.md` exists at the target directory root (project root), with default content controlled by `--lang` (default `go`) per the [AGENTS.md](https://agents.md/) format. Ensures a root `Makefile` exists by writing an embedded sample Makefile when missing. If appended workflow operations are present, sets effective working directory to the target directory and runs them in the exact order provided by the command line.

Allowed mutations: Creating the target directory when needed, creating missing initialization files, and optionally writing changes produced by explicitly requested workflow operations under the target directory. No mutations outside the target directory. No Git operations.

Must never do: Run any Git command (no `git init`, no add, no commit). Run plan/spec/work/e2e unless explicitly requested after init. Overwrite an existing `Makefile` by default during initialization. Create or modify anything outside the resolved target directory (except stderr and any documented stdout).

Language flag: `--lang` defaults to `go`. It controls which default or language-specific AGENTS.md content init installs at the project root, so init can scaffold modules for different programming languages. The set of supported values and their exact effect on installed content is implementation-defined and MUST be documented in the CLI reference.

**`bus dev commit`**

Intent: Create one or more commits from the currently staged changes only, with high-quality messages and strict safety rules, without touching remotes or history.

Preconditions: Effective working directory is the root of a Git repository (or a subdirectory of one). Optional: repository may contain submodules.

Reads: Git index and repository metadata (e.g. `git status`, `git diff --cached`). Does not read workspace datasets or accounting files for bookkeeping.

Writes: Only new commits created from the existing staging area (via `git commit`). Does not write to working tree files, does not create or modify files outside Git’s normal commit operation.

Allowed mutations: Creating new commit(s) from already-staged content. Committing in submodules first (depth-first), then the superproject only if it has staged changes. No other mutations.

Must never do: Modify files; stage anything (`git add`); amend, rebase, or rewrite history; push, pull, fetch, clone, or any remote operation; run hooks that are not the standard Git commit hooks (the tool may run `git commit`, which may run commit-msg/pre-commit etc.; the tool must not bypass or suppress hooks).

Behavior when nothing to commit: If there is nothing staged (and no staged changes in submodules that need committing), the command does nothing and exits with code 0. No commit is created, no error.

Submodules: If the repository has submodules and a submodule has staged changes, commit inside that submodule first (recursively depth-first). After all submodules with staged changes are committed, if the superproject has staged changes (including gitlink updates), commit the superproject. If a submodule commit resulted in an unstaged gitlink change in the superproject, the tool MUST report that clearly (e.g. to stderr) and STOP without staging that gitlink; the user must stage it manually if desired.

Commit message quality (normative): For every commit, the message MUST have a concise, action-oriented subject line in the imperative mood. A body MAY follow, separated by a blank line. The message SHOULD explain what changed and why, mention user-visible impact or risk when relevant, and include traceability (issue IDs or URLs) when helpful. Vague summaries are not acceptable. Conventional prefixes (feat, fix, docs, refactor, test, chore) MAY be used when they improve clarity but MUST NOT replace a precise subject.

Atomicity: Before creating each commit, the implementation (or the agent it invokes) MUST review the staged set at a high level. If the staged set contains multiple logical changes, the implementation/agent MUST propose an atomic commit split plan. By default, the tool commits exactly what is currently staged and MUST NOT alter the staging area to perform a split unless explicitly instructed.

Failures and hooks: If a commit is rejected by hooks (e.g. pre-commit, commit-msg), the tool MUST report the exact failure reason and output and suggest the minimal correction. The tool MUST NOT retry the commit automatically unless explicitly instructed.

**`bus dev stage`**

Intent: Prepare the working tree for commit so that only intended files are staged. The agent identifies temporary files, e2e test leftovers, build artifacts, and other files that should not be tracked; adds them (or patterns) to `.gitignore` or removes them from the project; then the tool stages all remaining changes. Enables combined invocations such as `bus dev plan work stage commit` without manually cleaning and staging.

Preconditions: Effective working directory is the root of a Git repository (or a subdirectory of one). The tool MUST resolve the repository root from the effective working directory. The agent runtime MUST be available (same resolution as for plan, work, spec, e2e).

Reads: Repository metadata to resolve the repository root. The agent reads the working tree, existing `.gitignore`, and (when present) AGENTS.md or project conventions to decide which files should not be tracked. Does not read workspace accounting datasets.

Writes: Determined by the agent under the embedded prompt: updates to `.gitignore` (add patterns or paths for files that should not be tracked), and optional removal of temporary files that should not exist in the working tree. After the agent completes, the tool updates the Git index (staging area) by staging all remaining changes at the repository root.

Allowed mutations: The agent may add entries to `.gitignore` and may remove files from the working tree that are purely temporary. The tool may then run local `git add` to stage all remaining changes at the repository root. No recursive staging inside submodules. No commit, amend, rebase, or remote operations.

Must never do: Commit; amend, rebase, or rewrite history; push, pull, fetch, clone, or any remote operation; stage inside submodules (only the current repository’s working tree is in scope). The agent must not stage files that the prompt defines as unintended (temporary, e2e leftovers, etc.); it must ignore or remove them first.

**`bus dev work`**

Intent: Run the canonical "do the work in this repo now" agent workflow: implement code changes, add/update tests, run Makefile checks, and update README in the current module repository, following the module’s AGENTS.md and design docs.

Preconditions: Effective working directory is inside a BusDK module Git repository. The repository contains AGENTS.md and design docs that the agent will read. When the selected runtime is Gemini CLI, repository-local Gemini context (e.g. repo-root `GEMINI.md`, `.gemini/settings.json`, `.geminiignore`) may also be present; Bus Dev supports AGENTS.md and Gemini context in parallel without changing this workflow.

Reads: Repository source code, repository-root `AGENTS.md`, design docs (e.g. SDD, CLI reference) as referenced by AGENTS.md, and `PLAN.md` when it exists. When `PLAN.md` exists, the prompt requires the agent to review it first and prioritize its unchecked items while retaining checked items as completed history until plan pruning. When Gemini CLI is selected, the agent also reads repo-root and directory-scoped `GEMINI.md`, `.gemini/settings.json`, and respects `.geminiignore` for context ingestion. The agent is allowed to read these as the authoritative specs for that repo. Bus Dev does not read or modify user-global Gemini config or memory; developers who want global Gemini memory must manage it manually outside Bus Dev.

Writes: Determined by the agent under the constraints of the embedded prompt (code, tests, README, and `PLAN.md` item check-offs when applicable). The tool itself does not write repository files directly; it only invokes the agent with the embedded prompt.

Allowed mutations: Whatever the embedded prompt permits (code, tests, README, and checking off completed `PLAN.md` items), under the rule that the agent operates only in the current module and follows the module’s rules.

Must never do: Invoke remote Git operations; operate outside the current module repository; change workspace accounting datasets; remove already checked items from `PLAN.md`; modify user-global Gemini configuration or memory (see Headless and script mode and Gemini CLI integration). In headless or script mode, the agent MUST NOT perform network operations or other prohibited actions.

Implementation note: The workflow is executed via an embedded prompt template shipped inside bus-dev. Documentation links in the prompt (e.g. main SDD, module SDD, module end-user docs) are derived from the configurable docs base URL (FR-DEV-004b) and the prompt variable catalog (`MAIN_SDD_URL`, `MODULE_SDD_URL`, `MODULE_DOCS_URL`). The agent runtime reads the repository’s own docs, AGENTS.md, and (when Gemini is selected) repository-local Gemini context as part of doing the work; those are the authoritative specs for that repo. For a concrete picture of repo-local files and what each is responsible for, see the Gemini CLI integration subsection.

**`bus dev plan`**

Intent: Build a compact prioritized implementation plan for the current module repository by comparing documented requirements to repository reality, then write that plan to `PLAN.md`.

Preconditions: Effective working directory is inside a BusDK module Git repository. The agent runtime is available. Documentation URLs derived from the docs base URL are reachable to the selected runtime.

Reads: Repository files, current tests, current docs in the repository, existing `PLAN.md` when present, the main SDD URL (`MAIN_SDD_URL`), the current module SDD URL (`MODULE_SDD_URL`), the current module end-user docs URL (`MODULE_DOCS_URL`), and other project SDD pages relevant to requirement coverage. The prompt uses these sources to re-validate existing plan items and to detect unimplemented features and other undone work.

Writes: `PLAN.md` at repository root only. The file is a compact Markdown checklist with unchecked items ordered by priority.

Allowed mutations: Creating or overwriting repository-root `PLAN.md`.

Must never do: Modify source code, tests, README, AGENTS.md, or any file other than `PLAN.md`. Include implementation-level instructions that duplicate or override project SDD details.

Plan format contract: `PLAN.md` contains one unchecked item (`- [ ]`) per still-undone or newly detected unimplemented feature or undone work item that the command determines from documented sources and repository state. If `PLAN.md` already exists, its prior items are treated as candidates: items now completed are removed, and items still undone are retained and reprioritized with newly discovered items in one combined list. Items are concise and action-oriented, with enough context for the next execution step, and avoid implementation details because implementation must come from project SDD and related documentation. If no undone work is detected after re-validation, the file still exists and states that no open items were found.

**`bus dev spec`**

Intent: Ensure the current repository has a compact but detailed local spec in AGENTS.md that reflects the latest BusDK specifications and describes how to implement this tool; create AGENTS.md from online SDD and user documentation when missing; no changes to source code, tests, or README.

Preconditions: Effective working directory is inside a BusDK module Git repository. When the selected runtime is Gemini CLI, Bus Dev uses repository-local Gemini context in parallel with AGENTS.md; headless and script mode constraints apply as in Headless and script mode.

Reads: The current AGENTS.md when it exists (subject of refinement); when it does not exist, the agent produces it from online docs. If `.cursor/rules/<MODULE_NAME>.mdc` exists (module name per FR-DEV-003), the tool reads it and includes its content in the refinement context so the agent can merge it into AGENTS.md. BusDK documentation is referenced via the embedded prompt; links are derived from the docs base URL and prompt variables such as `MAIN_SDD_URL`, `MODULE_SDD_URL`, `MODULE_DOCS_URL`, and `AGENTS_FILE_PATH` per the prompt variable catalog. When Gemini CLI is selected, the agent may also use repo-local `GEMINI.md` and `.gemini/settings.json`. The agent may read the spec pages and the AGENTS.md format to align the file.

Writes: The single file `AGENTS.md` at the repository root (created when missing, otherwise updated). After a successful refinement that incorporated Cursor rule content, the tool MUST remove `.cursor/rules/<MODULE_NAME>.mdc` if it existed. Bus Dev does not write to any user-global Gemini config or memory.

Allowed mutations: Creating or updating AGENTS.md; deleting `.cursor/rules/<MODULE_NAME>.mdc` only after its content has been refactored into AGENTS.md (FR-DEV-008a).

Must never do: Modify source code, tests, README, or any file other than repository-root `AGENTS.md` and the single Cursor rule file specified above; perform Git operations other than those implied by the user saving the file (if the agent writes the file, the user may then commit).

AGENTS.md path: The tool MUST use the path `AGENTS.md` at the repository root (no module-derived path). When AGENTS.md does not exist, the tool MUST create it in the same run by having the agent produce it from the online SDD and module end-user documentation, so the result is a compact but detailed local implementation spec for the current module.

**`bus dev e2e`**

Intent: Guided workflow to detect missing end-to-end tests for the current module and scaffold them in a hermetic way, consistent with BusDK testing conventions and the module’s SDD and end-user documentation.

Preconditions: Effective working directory is inside a BusDK module Git repository. The module has (or the tool can resolve) an SDD and end-user documentation so that required test coverage can be determined.

Reads: Repository layout, existing tests under `tests/`, the module’s SDD document, end-user documentation (e.g. CLI reference) for the current module, and `PLAN.md` when it exists. When `PLAN.md` exists, the prompt requires the agent to review it first, validate that each checked item is fully covered by e2e tests, and prioritize unchecked test-related items. Documentation links in the prompt are derived from the docs base URL (FR-DEV-004b) and the prompt variable catalog (`MAIN_SDD_URL`, `MODULE_SDD_URL`, `MODULE_DOCS_URL`, `E2E_SCRIPT`, `E2E_SCRIPT_PATH`, `E2E_WORKSPACE_DIR`, `PLAN_FILE`, `PLAN_FILE_PATH`). The tool uses these inputs both to verify checked-item coverage and to discover other untested behavior from the SDD and end-user docs. Agent-specific rules (e.g. AGENTS.md) define language and module-specific testing expectations and are used when generating or refining scaffolds.

Writes: New or updated test files under `tests/` only. E2E scripts MUST be named `e2e_bus_<name>.sh` where `<name>` is the module name with the `bus-` prefix stripped (e.g. `bus-accounts` → `tests/e2e_bus_accounts.sh`). Scaffold content MUST align with the behavior described in the SDD and end-user docs and with agent rules. No modification of production code.

Allowed mutations: Adding or updating files under `tests/` (e.g. `e2e_bus_<name>.sh` and any agreed boilerplate) as defined by the subcommand’s acceptance criteria. If `PLAN.md` is touched by this workflow, checked items MUST be preserved and must not be removed.

Must never do: Remote Git operations; history rewriting; modifying workspace accounting datasets; removing already checked items from `PLAN.md`; non-hermetic or network-dependent test scaffolding.

Detection and scaffold: The tool detects missing e2e tests by comparing required coverage (derived from the module’s SDD and end-user documentation, with URLs supplied via the prompt variable catalog) to existing tests under `tests/`. When `PLAN.md` exists, checked items are treated as completed feature commitments and MUST be verified as fully covered by existing or newly scaffolded e2e tests; coverage gaps for checked items are reported and scaffolded. The command also continues discovering other untested documented behavior that may not appear in `PLAN.md`. The exact scaffold (file names, boilerplate, and suggested cases) is deterministic: it follows the `tests/e2e_bus_<name>.sh` naming and directory layout, and the content is generated to cover the behavior and CLI surface described in the SDD and end-user docs. Language- and module-specific details (e.g. how to build or invoke the binary, Go test layout) are defined in agent instructions (e.g. AGENTS.md) and are used when the agent runs or when the tool produces guidance. When `bus dev e2e` invokes an agent, Headless and script mode and repository-local-only Gemini rules apply; the agent must not perform network operations or modify user-global Gemini config or memory.

### I/O Conventions

Standard output: Reserved for deterministic, machine-readable command results when a subcommand produces them. For subcommands that only invoke an agent and stream human-readable output, stdout may be unused or used for a final success message in a documented format.

Standard error: All diagnostics, progress, and human-readable agent output (e.g. NDJSON formatted to text) MUST go to stderr. This preserves the BusDK convention that stdout is for results and stderr for diagnostics. At the start of each agent-invoking step (plan, work, spec, e2e, stage), the tool MUST write a single line to stderr that identifies the internal agent runtime and model in use for that step (FR-DEV-005e), so that logs and scripts can see which agent and model were used.

When an external agent is invoked, the agent’s raw output (e.g. NDJSON) may be piped through an internal formatter that writes readable text to stderr. The tool MUST NOT inject color or control sequences into stdout when the output is intended to be machine-readable.

Determinism: Given the same repository state, same staged set, and same flags, the tool MUST produce the same exit code and consistent stderr output (up to timing or non-deterministic agent output when an agent is used; the tool’s own messages and exit code must still be deterministic for the "no agent" and "stub agent" cases).

### Exit Codes

- 0: Success. For `bus dev commit`, "nothing to commit" is success (0).
- 1: Execution failure (e.g. Git command failed, hook failed, agent failed or timed out, selected agent runtime not found or not executable, or no agent enabled when the automatic default would apply).
- 2: Invalid usage (e.g. unknown subcommand, invalid flag including invalid `--agent` or `set agent` runtime name, missing required argument, or precondition not met — e.g. not in a Git repository for repo-scoped commands, or init target path is not a directory).

The distinction between invalid usage (2) and execution failure (1) follows BusDK CLI conventions: usage errors are 2; failures during an otherwise valid invocation are 1.

### Error Handling and Resilience

- **Configured agent runtime not installed or not in PATH:** When the user has selected an agent (via flag or session preference) and that agent’s CLI is not found or not executable, the tool MUST surface the failure from the bus-agent library and MUST exit with a clear diagnostic to stderr and a non-zero exit code (1). The message MUST indicate that the selected agent runtime could not be found or executed and MUST direct the user to the canonical installation URL for that runtime; bus-agent provides the installation reference (FR-AGT-010) and bus-dev uses it in the diagnostic.
- **No agent available (automatic default):** When no runtime is selected via flag or session preference and the automatic default would apply, but no agent is available (no enabled CLI in PATH, or all are disabled, or enable list excludes all), the tool MUST exit with a clear diagnostic to stderr and a non-zero exit code (1 or 2). The message MUST state that at least one supported agent runtime must be installed or enabled and MUST direct the user to the canonical installation URLs; bus-dev uses the installation references provided by the bus-agent library to build this message.
- **git not installed or not in PATH:** When a subcommand needs Git, the tool MUST detect failure to run `git` and MUST exit with a clear diagnostic and non-zero exit code (1).
- **Working directory not a Git repo:** For subcommands that require a Git repository (commit, stage, plan, work, spec, e2e when run standalone), exit with code 2 and a clear message. For `bus dev init`, the effective working directory need not be a Git repository; init targets the current directory by default or the provided `DIR` path and initializes missing files there.
- **No staged changes (commit):** Exit 0 and do nothing; optionally print a short message to stderr that there was nothing to commit.
- **Hooks fail (commit):** Exit 1 and report the hook failure output; do not retry.
- **Timeouts (agent subcommands):** When the agent run (via the bus-agent library) exceeds the configured timeout, the tool MUST exit with a non-zero code (1) and MUST report that the run timed out.

- **Lock acquisition failure:** When a subcommand requires the working-directory lock (init, commit, stage, plan, work, spec, e2e) and the lock cannot be acquired because the directory is not writable, the lock file cannot be created, or the platform does not support the required locking primitive, the tool MUST exit with a clear diagnostic to stderr and a non-zero exit code (1). The message MUST indicate that the working-directory lock could not be acquired and SHOULD suggest checking directory permissions or concurrent `bus dev` usage.

All error messages MUST be written to stderr. The tool MUST NOT crash or exit with an ambiguous code when the above conditions occur; behavior MUST be as specified.

### Data Design

Bus Dev does not own or read workspace datasets (CSV, schemas, datapackage.json) for bookkeeping. It operates on:

- **Working-directory lock file.** To enforce single-instance execution per directory (FR-DEV-012, IF-DEV-005), the tool uses an exclusive lock keyed by the effective operation directory. The lock MUST be implemented using a lock file at a deterministic path within that directory (e.g. `<effective-operation-dir>/.bus-dev.lock`). The implementation MUST use an exclusive file lock (e.g. `flock` or equivalent) so that only one process holds the lock at a time; blocking until the lock is acquired when another process holds it. The lock file MAY be created if missing; it MUST be released when the process exits. For `bus dev init` when the target directory does not exist, the directory is created first per FR-DEV-010, then the lock is acquired in that directory. The lock file is an implementation detail and may be left on disk after a normal run; it does not contain user data and is used only for mutual exclusion.

- The Git repository (metadata and index) for the current working directory.
- The repository’s working tree (source files, repository-root `AGENTS.md`) when the agent is run, so the agent can read and optionally write files under the repo. When Gemini CLI is selected, Bus Dev only creates, edits, or relies on repository-scoped Gemini files: repo-root and optional directory-scoped `GEMINI.md`, `.gemini/settings.json`, and `.geminiignore`. Bus Dev never writes to the user’s home Gemini config directory (e.g. `~/.gemini/`) or to global memory (FR-DEV-005c, NG-DEV-005).
- Repository-root `PLAN.md` for planning continuity. `bus dev plan` creates or refreshes it as a compact unchecked priority list by re-validating existing items, removing completed checked items, and adding newly detected missing work. `bus dev work` reads it when present, prioritizes unchecked items, and checks off completed items without deleting checked items. `bus dev e2e` reads it when present, validates checked items against e2e coverage, prioritizes unchecked test-related items, and does not delete checked items.
- No persistent data store beyond what Git and the filesystem provide for bus-dev’s own state. Agent selection follows the order in FR-DEV-005b and FR-AGT-005: per-command `--agent`, then `BUS_DEV_AGENT`, then `BUS_AGENT`, then bus-dev persistent preference (`bus-dev.agent`), then bus-agent preference (`bus-agent.runtime`), then first available runtime. Run-config (model, timeout, output-format) follows the same logic: per-command override if present, then `BUS_DEV_MODEL`, `BUS_DEV_TIMEOUT`, `BUS_DEV_OUTPUT_FORMAT`, then bus-dev persistent preferences (`bus-dev.model`, `bus-dev.timeout`, `bus-dev.output_format`), then bus-agent preferences as fallback, then bus-agent defaults. Bus-dev writes only to the `bus-dev` namespace when the user runs `bus dev set` (agent, model, output-format, timeout); it never writes to `bus-agent.*` or any other namespace via the bus-preferences library. Preferences are read via the [bus-preferences](./bus-preferences) library; the user sets bus-dev defaults with `bus dev set agent|model|output-format|timeout` or with `bus preferences set bus-dev.<key> <value>` (e.g. `bus preferences set bus-dev.agent gemini`). When a configured runtime is disabled, bus-agent prints a warning and resolution continues with the next source (FR-AGT-005b). User-configured agent order and enable/disable are passed through to bus-agent. No bus-dev-specific config file is required; configuration is via flags, environment, and bus-preferences.

### Assumptions and Dependencies

AD-DEV-001 Git is available. The commit workflow and repository resolution depend on `git` being in PATH and the repository being a valid Git repo. If Git is missing or the directory is not a repo, the tool fails with a clear error.

AD-DEV-002 Agent runtime availability. Subcommands that invoke an agent (plan, work, spec, e2e, and stage) require the chosen agent runtime (Cursor CLI, Codex, Gemini CLI, or Claude CLI) to be installed and in PATH when those subcommands are run. The chosen runtime is either explicitly selected (flag or session preference) or the automatic default (first available agent in bus-agent’s effective order, alphabetic when no user order is set). If the explicitly selected agent is missing, the tool reports that and exits non-zero; it does not silently fall back. If no agent is selected and none are available, the tool exits with a clear message directing the user to install or enable at least one supported agent (FR-DEV-005d).

AD-DEV-003 Repository layout. For `bus dev spec`, the agent-instruction file is `AGENTS.md` at the repository root (per the [AGENTS.md](https://agents.md/) convention). If the project adopts a different convention, this assumption will be updated in the SDD.

AD-DEV-004 Operating environment. Same as BusDK: Linux and macOS. Tests and behavior are defined for these environments; Windows is out of scope unless otherwise stated.

AD-DEV-005 bus-agent dependency. Bus Dev depends on the bus-agent Go module for agent execution. The bus-agent library provides the runner interface, supported runtimes (Cursor, Codex, Gemini, Claude), runtime detection, selection resolution, prompt-template rendering contract, timeout enforcement, output capture/streaming, and installation references for diagnostics. If bus-agent is unavailable or its interface changes in an incompatible way, bus-dev’s agent-invoking subcommands (plan, work, spec, e2e, and stage) are affected; bus-dev does not implement a fallback agent runner.

### Testing Strategy

- **Unit tests.** All library-style code (repo resolution, argument parsing including multiple operations (FR-DEV-001a), init target resolution and scaffold creation, prompt template expansion, and agent invocation via bus-agent with stub) MUST have unit tests. Tests MUST be hermetic: no network, no real Git remotes, no real agent. Parsing and execution of multi-op invocations (e.g. spec, work, e2e in one call, and init with appended operations) MUST be covered; when a stub agent returns non-zero for the second operation, the third MUST not run and the exit code MUST be that of the failed operation. Tests MUST verify that plain `bus dev init` does not invoke any agent operation and that a missing root `Makefile` is created from the embedded sample while an existing `Makefile` is preserved. Plan-specific tests MUST verify that `bus dev plan` writes only `PLAN.md`, produces only unchecked checklist items, orders them by priority, and keeps item text compact and non-implementation-specific. Plan-specific tests MUST also verify rerun behavior when `PLAN.md` already exists: completed checked items are removed, still-undone items remain, and newly detected missing work is added. Work-specific tests MUST verify that completed plan items are checked off and that checked items are never removed by work. E2E-specific tests MUST verify checked-item coverage validation and additional untested-feature discovery from SDD/docs while preserving checked plan items. Spec-specific tests MUST verify that when AGENTS.md is missing, the command creates it (via stubbed agent) from online SDD and user docs so the result is a compact local implementation spec, and that when `.cursor/rules/<MODULE_NAME>.mdc` exists, its content is merged into AGENTS.md and the file is then removed (FR-DEV-008, FR-DEV-008a).

- **Prompt rendering tests.** Unit tests MUST cover the prompt-template rendering contract (FR-DEV-004a): (1) missing variable — when a required variable is not supplied, the command MUST fail with a clear diagnostic and exit code 2 before any agent invocation; (2) unresolved variable — when any {% raw %}`{{...}}`{% endraw %} token remains after substitution, the command MUST fail with a clear diagnostic and exit code 2 before agent invocation; (3) repeated placeholder replacement — the same variable MAY appear multiple times in a template and each occurrence MUST be replaced consistently; (4) expected placeholder set per prompt template — each template’s required variables MUST be documented and tests MUST verify that supplying that set yields a fully resolved prompt; (5) docs base override — when `BUS_DEV_DOCS_BASE_URL` is set (and when unset), derived URLs (`MAIN_SDD_URL`, module SDD URL, module docs URL) MUST match the specified formulas and normalization (trailing slash trimmed). Tests for work and e2e prompts MUST verify that `PLAN.md` is included in prompt context when present and omitted cleanly when absent, and that prompt instructions enforce the checked-item lifecycle rules.

- **Fixture repository.** At least one end-to-end style test MUST use a fixture Git repository in a temporary directory (e.g. a repo with a few commits and optionally a submodule) to verify commit behavior: nothing to commit exits 0, staged change leads to commit with message, submodule ordering, unstaged gitlink handling, etc. This test MUST not push or pull; it may run `git commit` only.

- **Agent runner tests.** When the agent is involved, the test strategy MUST stub the agent binary in PATH (or inject a fake path). The stub MUST feed deterministic NDJSON (or plain output) to stdout and exit with a chosen code so that parsing, filtering, and error handling are exercised without calling a real agent or network. Agent detection and automatic default selection (FR-DEV-005d) MUST be testable by controlling PATH so that zero, one, or multiple agent CLIs appear to exist; tests MUST verify that the chosen default is deterministic and that "no agent enabled" yields a clear exit and diagnostic.

- **Locking tests.** Tests MUST verify working-directory lock behavior (FR-DEV-012): (1) two concurrent invocations that target the same effective operation directory run one after the other — the second blocks until the first exits; (2) the lock is released on normal exit, on non-zero exit, and on process termination so that a subsequent invocation can acquire it; (3) `bus dev set …` does not acquire the lock and does not block on a running init/plan/work/spec/e2e/stage/commit in the same directory. Tests MAY use a helper process that holds the lock while a second process blocks, or use a fixture that asserts serialized execution; hermetic tests MUST NOT rely on real wall-clock timing for correctness.

- **Definition of Done.** For any implementation of this SDD, the following are required: unit tests for the new or touched code paths, at least one end-to-end style test using a fixture repo as above, locking tests as above, and README updates that document the subcommands and link to this SDD and the canonical BusDK design spec where relevant.

### Traceability to BusDK Spec

This module intentionally deviates from the following BusDK design spec elements, and is constrained by the following:

- **NG-001 (BusDK does not execute Git commands).** Bus Dev is the defined exception: it may run local Git commands (status, diff, commit) under the strict constraints in this SDD (no remote, no history rewrite, no staging). Rationale: developer workflow centralization without putting Git into every module.

- **CLI conventions.** Bus Dev follows the same global CLI conventions as other modules (e.g. [Error handling, dry-run, and diagnostics](../cli/error-handling-dry-run-diagnostics), [Command structure and discoverability](../cli/command-structure)) for flags, stdout/stderr, and exit codes. Where it invokes an external agent, it still obeys the convention that machine-readable output (if any) is on stdout and diagnostics on stderr.

- **Module structure.** Bus Dev is implemented as a library-first, thin-CLI module consistent with [Module repository structure and dependency rules](../implementation/module-repository-structure) and [Independent modules](../architecture/independent-modules). It depends on the [bus-agent](./bus-agent) Go library for agent execution and does not implement its own agent runner; it does not invoke other `bus-*` binaries as subprocesses.

- **Testing.** The testing strategy aligns with the BusDK [Testing strategy](../testing/testing-strategy): hermetic, no network, deterministic, and with command-level or fixture-based tests where appropriate.

The most relevant BusDK spec pages for implementors are: the [BusDK Software Design Document (SDD)](../sdd) (goals and non-goals, especially NG-001), [CLI tooling and workflow](../cli/index), [Error handling, dry-run, and diagnostics](../cli/error-handling-dry-run-diagnostics), [Module repository structure and dependency rules](../implementation/module-repository-structure), and [Testing strategy](../testing/testing-strategy).

### Glossary and Terminology

- **Module name:** The identifier used for the current repository when a subcommand needs it (e.g. for docs URLs or e2e script naming). It is derived deterministically as the base name of the repository root directory (the last path component of the absolute path to the repo root). See FR-DEV-003 and IF-DEV-004.

- **Staging area / Git index:** The set of changes that have been `git add`ed and will be included in the next `git commit`. Bus Dev commit operates only on this set; it does not add or remove from it.
- **Gitlink:** The Git submodule pointer (commit SHA) stored in the superproject tree for a submodule. When you commit inside a submodule, the superproject’s view of that submodule becomes an unstaged gitlink change until the user stages it.
- **AGENTS.md:** The single repository-root file that provides agent instructions per the [AGENTS.md](https://agents.md/) open format. It MUST be a compact but detailed local spec for implementing the current module, grounded in the module’s SDD and end-user documentation. Bus Dev spec creates AGENTS.md from online SDD and user docs when missing, then refines it; when it exists, spec refines it in place. Init ensures AGENTS.md exists at the project root, creating default content when missing; that content may depend on `--lang`.
- **Cursor rule file (spec refactor):** For `bus dev spec`, the optional file at `.cursor/rules/<MODULE_NAME>.mdc` (where `<MODULE_NAME>` is the module name, e.g. `bus-accounts`). When present, the tool includes its content in the refinement context, the agent refactors that content into AGENTS.md, and the tool then removes the file so agent instructions live only in AGENTS.md. This is the only permitted exception where bus-dev may remove or replace existing repo content for instruction standardization (FR-DEV-008a, NFR-DEV-008). See FR-DEV-008a.
- **Bus-owned block:** A contiguous block of content in a repo-local file (e.g. CLAUDE.md, .gemini/settings.json) added by BusDK with an explicit marker so it can be identified and updated without touching existing user content. All such changes are append-only; user content is never removed or rewritten except the legacy .cursor/rules/<MODULE_NAME>.mdc exception. See NFR-DEV-008 and the [bus-agent](./bus-agent) SDD.
- **Agent runner:** The abstraction that invokes the configured external agent runtime (Cursor CLI, Codex, Gemini CLI, or Claude CLI) with a prompt, timeout, and output formatting. In bus-dev this is provided by the [bus-agent](./bus-agent) Go library; bus-dev does not implement the runner itself. The active runtime is selectable via a flag or environment variable; supported runtimes and backends are defined in the bus-agent SDD.

- **Cursor CLI:** One of the supported agent runtimes. The Cursor CLI backend invokes the cursor-agent (or equivalent) executable. Used when the user selects the Cursor CLI option.

- **Codex:** One of the supported agent runtimes. The Codex backend invokes the Codex CLI (or equivalent) executable. Used when the user selects the Codex option. Integration is modular so that prompt, workdir, and I/O contract are the same across all backends.

- **Gemini CLI:** One of the supported agent runtimes. The Gemini CLI backend invokes the Gemini CLI (or equivalent) executable. Used when the user selects the Gemini CLI option. Integration is modular so that prompt, workdir, and I/O contract are the same as for other backends. Bus Dev supports repository-local Gemini context (e.g. `GEMINI.md`, `.gemini/settings.json`, `.geminiignore`) in parallel with AGENTS.md and never modifies user-global Gemini configuration or memory (see Gemini CLI integration and NG-DEV-005).

- **MDC-style configuration (Gemini):** In Gemini CLI terms, the use of project-level context and settings files that play a role analogous to Cursor’s `.cursor/rules/*.mdc` and project settings: the Gemini CLI loads context from markdown files (by default `GEMINI.md`) and respects a project `.gemini/settings.json` and `.geminiignore`. Bus Dev documents and manages only the repository-local layer of this configuration.

- **PLAN.md:** Repository-root compact priority task list generated by `bus dev plan`. Each task written by `bus dev plan` is an unchecked item for one still-undone or newly detected unimplemented feature or other undone work item from documentation and repository state. `bus dev work` checks off items it completes and preserves previously checked items. `bus dev e2e` uses checked items as completed-feature coverage obligations and preserves checked items. On rerun, `bus dev plan` is the only command that prunes completed checked items and merges newly detected missing work into the prioritized unchecked list.

- **Repository-local (Gemini):** The set of Gemini-related files that Bus Dev may create, edit, or rely on, all under the current repository: repo-root `GEMINI.md`, optional directory-scoped `GEMINI.md`, `.gemini/settings.json`, and `.geminiignore`. Contrast with user-global Gemini config (e.g. `~/.gemini/GEMINI.md`) and global memory, which Bus Dev must never modify.

- **Headless and script mode:** Invocation of `bus dev` (and thus of the agent) from a non-interactive environment (script, CI, headless runner). In this mode workflows MUST remain non-interactive and MUST NOT perform prohibited actions such as network operations or modifying user-global Gemini config or memory.

- **Claude CLI:** One of the supported agent runtimes. The Claude CLI backend invokes the Claude CLI (or equivalent) executable. Used when the user selects the Claude CLI option. Integration is modular so that prompt, workdir, and I/O contract are the same as for other backends.

- **Enabled agent:** An agent runtime whose CLI command exists at resolution time (e.g. the corresponding executable is found in PATH and is executable). The **available** set for automatic default is determined by bus-agent and may be restricted by user-configured enable/disable (FR-AGT-005a). When the user does not specify a runtime, bus-dev delegates to bus-agent for the automatic default from available runtimes in bus-agent’s order (alphabetic when no user order is set) (FR-DEV-005d).

- **Session-stored preference:** The user’s default choice of agent runtime for the current session. Stored in an environment variable (e.g. `BUS_DEV_AGENT`) so that every `bus dev` command in that shell session uses that runtime unless overridden by the `--agent` flag. Easy to change by re-exporting the variable or by using the flag for a single command.

- **Working-directory lock:** An exclusive lock keyed by the effective operation directory so that only one `bus dev` invocation (init, commit, stage, plan, work, spec, or e2e) runs at a time per directory. A second invocation for the same directory blocks until the first exits and releases the lock. Implemented via a lock file (e.g. `.bus-dev.lock`) and an exclusive file lock. See FR-DEV-012 and IF-DEV-005.

- **Embedded prompt:** A prompt string or template compiled into the bus-dev binary, not loaded from the filesystem.

- **DOCS_BASE_URL:** The base URL for BusDK documentation used to build all documentation links in prompts and diagnostics. Configurable via `BUS_DEV_DOCS_BASE_URL` (default `https://docs.busdk.com`); normalized by trimming a trailing slash. See FR-DEV-004b and the prompt variable catalog.

- **MAIN_SDD_URL:** The URL of the main BusDK SDD index page. Derived as `<DOCS_BASE_URL>/sdd`. Used in prompts and diagnostics when referring to the design spec. See FR-DEV-004b and the prompt variable catalog.

- **Prompt-template variable rendering contract:** The normative behavior for substituting {% raw %}`{{VARIABLE}}`{% endraw %} placeholders in embedded prompts: rendering MUST be deterministic; missing or unresolved placeholders MUST cause the command to fail before agent invocation (exit code 2). Ensures the agent never receives partially substituted text. See FR-DEV-004a, NFR-DEV-001, NFR-DEV-005.

- **E2E test script (Bus module):** A Bash script that runs the module’s compiled binary to exercise end-to-end behavior. It MUST live under `tests/` and MUST be named `e2e_bus_<name>.sh` where `<name>` is the module name with the `bus-` prefix stripped (e.g. `bus-accounts` → `tests/e2e_bus_accounts.sh`). See KD-DEV-006 and FR-DEV-009.

<!-- busdk-docs-nav start -->
<p class="busdk-prev-next">
  <span class="busdk-prev-next-item busdk-prev">&larr; <a href="./bus-data">bus-data</a></span>
  <span class="busdk-prev-next-item busdk-index"><a href="./index">SDD index</a></span>
  <span class="busdk-prev-next-item busdk-next"><a href="./bus-bfl">bus-bfl</a> &rarr;</span>
</p>
<!-- busdk-docs-nav end -->

### Sources

- [bus-agent module SDD](./bus-agent)
- [bus-preferences module SDD](./bus-preferences)
- [bus-config module SDD](./bus-config)
- [BusDK Software Design Document (SDD)](../sdd)
- [CLI tooling and workflow](../cli/index)
- [Error handling, dry-run, and diagnostics](../cli/error-handling-dry-run-diagnostics)
- [Module repository structure and dependency rules](../implementation/module-repository-structure)
- [Testing strategy](../testing/testing-strategy)
- [End user documentation: bus-dev CLI reference](../modules/bus-dev)
- [Gemini CLI — install](https://geminicli.com/)
- [Cursor CLI — overview and install](https://cursor.com/docs/cli/overview)
- [Claude Code — get started / install](https://github.com/anthropics/claude-code?tab=readme-ov-file#get-started)
- [Codex CLI — install](https://developers.openai.com/codex/cli/)
- [AGENTS.md — open format for guiding coding agents](https://agents.md/)

### Document control

Title: bus-dev module SDD  
Project: BusDK  
Document ID: `BUSDK-MOD-DEV`  
Version: 2026-02-13  
Status: Draft  
Last updated: 2026-02-13  
Owner: BusDK development team  
