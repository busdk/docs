---
title: bus-dev — Software Design Document
description: Bus Dev is a developer-only companion module that centralizes the workflow logic currently duplicated under scripts/ in each BusDK module repository.
---

## bus-dev

### Introduction and Overview

Bus Dev is a developer-only companion module that centralizes the workflow logic currently duplicated under `scripts/` in each BusDK module repository. It provides a single entry point for commit workflows, agent-runner workflows, MDC rule refinement, planning from documentation coverage gaps, and end-to-end test scaffolding, so module repositories can rely on `bus dev` instead of copying and maintaining per-repo scripts. Bus Dev does not implement agentic operations itself: it depends on the [bus-agent](./bus-agent) module through Go library access for all agent runtime execution, prompt-template rendering, runtime detection, and installation references. Bus Dev owns workflow semantics, embedded prompt content, repository and module resolution, and the commit workflow; bus-agent owns the runner abstraction, backends, and execution contract.

The problem it solves is duplication and drift: each BusDK module today may ship its own `scripts/commit.sh`, `scripts/work.sh`, `scripts/refine-mdc-spec.sh`, and `scripts/e2e.sh` (or equivalents), with slightly different behavior and prompts. Bus Dev consolidates that logic into one binary, `bus-dev`, invoked through the dispatcher as `bus dev …`, with embedded prompts and deterministic behavior.

Scope and boundaries are unambiguous. Bus Dev operates on source code repositories and developer workflows only. It does not operate on accounting datasets, workspace CSV, or schemas. It is not part of the end-user bookkeeping command surface. End users running `bus accounts`, `bus journal`, or `bus validate` never need `bus dev`; it exists for contributors and automation that work inside BusDK module Git repositories.

This module is an explicit exception to the BusDK-wide non-goal NG-001: "BusDK does not execute Git commands or commit changes." That non-goal applies to the accounting and workspace toolchain. Bus Dev is isolated to developer tooling and enforces strict safety constraints: no remote Git operations (no push, pull, fetch, clone, or submodule update that contacts a remote), no history rewriting (no amend, rebase, or squash), deterministic behavior, and clear diagnostics. The exception is justified by isolating Git use to a single, well-defined developer-only module and by making the constraints normative in this SDD.

The intended users are developers and automation (including AI agents) working inside a BusDK module repository. The document’s purpose is to serve as the single source of truth for implementation and review; the audience includes human reviewers and implementation agents.

Out of scope for this SDD: implementing accounting logic, modifying workspace datasets, providing end-user CLI commands for bookkeeping, and any workflow that pushes to or pulls from a remote.

### Goals

G-DEV-001 Centralize developer workflow logic. Replace per-repo scripts with a single `bus dev` command set so behavior and prompts are consistent and maintainable in one place.

G-DEV-002 Developer-only, repository-scoped operations. All operations run in the context of the current working directory as a Git repository and affect only source code, Cursor rules, and developer artifacts — never workspace datasets or end-user data.

G-DEV-003 Safety and determinism. No remote Git operations, no history rewriting, and deterministic output and exit codes so scripts and CI can rely on `bus dev` behavior.

G-DEV-004 Agent-friendly integration via bus-agent. Subcommands that invoke an external agent runtime use embedded prompts (owned by bus-dev) and depend on the bus-agent Go library for execution. The tool exposes consistent defaults for model and timeout and a well-defined contract for stdout/stderr and exit codes by using bus-agent’s runner, templating, and backend support; at least Cursor CLI, Codex, Gemini CLI, and Claude CLI are supported as selectable options through bus-agent.

G-DEV-005 Deterministic module root initialization. A single subcommand (`bus dev init [DIR]`) MUST initialize a module root in the current working directory by default, or in an explicitly provided target directory when `DIR` is given, without performing any Git operations. By default it initializes directory structure and baseline files only (including `.cursor/rules`, the module MDC file, and a root `Makefile` from an embedded sample when missing). Workflow operations (`spec`, `work`, `e2e`) run only when the user explicitly appends them (for example `bus dev init spec work e2e` or `bus dev init DIR spec work e2e`), and they execute in the exact order provided.

### Non-goals

NG-DEV-001 Bus Dev does not perform remote Git operations. Push, pull, fetch, clone, submodule update/init that contacts a remote, or any operation that could contact a remote is out of scope and must never be implemented.

NG-DEV-002 Bus Dev does not rewrite history. Amend, rebase, squash, or any operation that changes existing commit SHAs is out of scope.

NG-DEV-003 Bus Dev does not operate on workspace accounting datasets. Reading or writing workspace CSV, schemas, or datapackage.json for bookkeeping purposes is out of scope; that remains the domain of other BusDK modules.

NG-DEV-004 Bus Dev does not replace the bus dispatcher or module discovery. It is one module among many; the dispatcher continues to route `bus dev …` to the `bus-dev` binary.

NG-DEV-005 Bus Dev must never modify user-global Gemini configuration or memory. Any file under the user’s home Gemini config directory (e.g. `~/.gemini/`), including `~/.gemini/GEMINI.md`, and any global memory managed via interactive Gemini CLI commands (e.g. `/memory add`) are strictly off limits. Bus Dev may read global context only insofar as the Gemini CLI loads it by default when it runs; Bus Dev itself does not write, create, or edit anything outside the current repository. Developers who want global Gemini memory or user-level Gemini config must manage it manually outside Bus Dev.

### Requirements

FR-DEV-001 CLI integration and naming. The binary MUST be named `bus-dev` and MUST be invoked through the dispatcher as `bus dev <operation> [args]`. Acceptance criteria: the dispatcher routes `bus dev init`, `bus dev commit`, `bus dev plan`, `bus dev work`, `bus dev spec`, and `bus dev e2e` to the same binary; when multiple workflow operations are passed (e.g. `bus dev spec work e2e`), the binary receives all of them as positional arguments and executes them in order.

FR-DEV-001a Multiple workflow operations. The CLI MUST accept one or more consecutive operation names from the set {spec, work, e2e} in a single invocation. When two or more of these operations are given, the tool MUST execute them in the order given, one at a time, in the same process and effective working directory. If an operation exits non-zero, the run MUST stop immediately and the tool MUST exit with that operation’s exit code; subsequent operations in the list MUST NOT run. Acceptance criteria: `bus dev spec work e2e` runs spec, then work, then e2e in sequence; if work fails, e2e is not run and the exit code is work’s exit code; `bus dev init [DIR] spec work e2e` runs init first, then spec, then work, then e2e in that exact order; commit is not combinable with other operations (commit takes no further positionals).

FR-DEV-002 Repository discovery. For operations that require a repository context (commit, plan, work, spec, e2e when run standalone), the tool MUST determine the current working repository from the effective working directory (after applying `-C`/`--chdir` if present). It MUST NOT require configuration files or environment variables to locate the repo. Acceptance criteria: when run from inside a Git repository root or any subdirectory, the tool uses that repository as the scope for repository-scoped operations; when the effective working directory is not a Git repository, repository-scoped operations exit with a clear diagnostic and a non-zero exit code, while `init` remains valid because it operates on directory initialization rather than repository discovery.

FR-DEV-003 Module identity for spec and e2e. When a repository-scoped subcommand needs the current module name (e.g. for MDC path or docs URLs), the tool MUST derive it deterministically from the repository. The module name is the base name of the repository root directory (the last path component of the absolute path to the repo root). For `init`, which may run without a repository, the module name is derived from the base name of the resolved target directory. Acceptance criteria: the same repository always yields the same module name for repository-scoped operations; the same init target path always yields the same module name for initialization; no other derivation rule (e.g. canonical file) is used.

FR-DEV-004 Embedded prompts. All prompts used to drive agent runs MUST be embedded as Go string constants or templates inside the bus-dev binary. The tool MUST NOT load prompts from external prompt files on disk. Acceptance criteria: a fresh clone of the bus-dev repo builds a binary that runs all subcommands without requiring any external prompt files; prompts may still be overridden or extended by flags or environment variables when explicitly documented.

FR-DEV-004a Prompt-template rendering contract. Embedded prompts that use placeholders MUST use the `{{VARIABLE}}` syntax. Bus-dev MUST use the bus-agent library’s template renderer (or a contract-compatible implementation) so that rendering is deterministic and satisfies the same strict guarantees as bus-agent’s FR-AGT-006: missing or unresolved placeholders MUST cause the command to fail before any agent invocation, with a clear diagnostic and exit code 2. Rendering a template with no placeholders is a pass-through. This contract is part of the determinism and safety guarantees (NFR-DEV-001, NFR-DEV-005): the tool MUST NOT invoke an agent with partially substituted or ambiguous prompt text. Acceptance criteria: unit tests cover missing variable, unresolved variable, repeated placeholder replacement, and expected placeholder set per prompt template; the agent is never invoked when substitution fails.

FR-DEV-004b Configurable docs base URL. The documentation base URL used to derive links in prompts and diagnostics MUST be configurable via the environment variable `BUS_DEV_DOCS_BASE_URL`. The default MUST be `https://docs.busdk.com`. The value MUST be normalized by trimming any trailing slash before use. This value is used to derive documentation links (including the main SDD URL and module-specific SDD and module-docs URLs) that appear in embedded prompts and in diagnostics. The main SDD URL is a first-class derived value: `MAIN_SDD_URL = <DOCS_BASE_URL>/sdd`. The module SDD URL is `<DOCS_BASE_URL>/sdd/<module>` and the module docs URL is `<DOCS_BASE_URL>/modules/<module>`, where `<module>` is the module name (base name of the repository root directory, per FR-DEV-003). Acceptance criteria: when unset, derived URLs use the default base; when set, they use the normalized value; trailing slash is removed; tests verify override effects on derived URLs.

FR-DEV-005 Dependence on bus-agent for agent execution. The implementation MUST depend on the bus-agent Go library for invoking the configured external agent runtime. Bus-dev MUST use bus-agent’s runner interface, template renderer, runtime detection, and installation references rather than reimplementing them. Model, output format, and timeout remain configurable via flags or environment variables; defaults are documented and deterministic. Acceptance criteria: bus-dev imports and uses the bus-agent package for all agent invocations; model, output format, and timeout are configurable via flags or environment; the integration is testable in isolation (e.g. by stubbing or mocking the bus-agent dependency or the executable in PATH as supported by bus-agent).

FR-DEV-005a Supported agent runtimes via bus-agent. The implementation MUST use bus-agent’s supported runtimes (Cursor CLI, Codex, Gemini CLI, Claude CLI). Bus-dev MUST NOT implement its own agent backends; it MUST delegate to the bus-agent library for backend selection and execution. The active runtime MUST be selectable via a documented flag or environment variable (e.g. `--agent cursor|codex|gemini|claude` or equivalent) that bus-dev passes through to bus-agent’s selection resolution. Acceptance criteria: the user can select any of the four runtimes; switching runtime does not change subcommand semantics or embedded prompts; bus-agent’s backends and installation references are the single source of truth; documentation lists all runtimes and selection mechanism and references the bus-agent SDD where appropriate.

FR-DEV-005b Agent selection configuration. The implementation MUST expose configuration so that the user can choose which agent runtime to use, and that choice MUST be easy to change both per command and for the session. Bus-dev MUST pass the user’s selection (or absence thereof) to the bus-agent library, which performs resolution per its contract (FR-AGT-005). Concretely: (1) A per-command override (e.g. `--agent <runtime>`) MUST select the runtime for that invocation only. (2) A session-stored preference (e.g. `BUS_DEV_AGENT`) MUST be supported and passed to bus-agent when no per-command override is present. (3) The resolution order MUST match bus-agent’s resolution order: per-command flag overrides session preference; session preference overrides persistent preference from bus configuration; persistent preference (read by bus-agent via the [bus-config](./bus-config) library) overrides automatic default; otherwise bus-agent’s automatic default applies (see FR-DEV-005d). The user sets the persistent default with `bus config set agent <runtime>`; that value is saved in bus configuration and read by bus-agent through the bus-config Go library. Acceptance criteria: the user can set a preference once per session and run multiple `bus dev` commands without re-specifying; the user can override for a single command; the resolution order is documented; invalid runtime names yield a clear usage error (exit 2). The implementation MAY support a persistent user preference; if so, its place in the resolution order MUST be documented and MUST be passed through to bus-agent consistently.

FR-DEV-005d Agent detection and automatic default. The implementation MUST use bus-agent’s runtime detection and automatic-default selection rather than implementing its own. When no per-command flag, no session-stored preference, and (if supported) no persistent preference specify a runtime, bus-dev MUST call bus-agent’s resolution so that the automatic default is chosen from available runtimes in bus-agent’s documented order (alphabetic by runtime ID when no user order is configured; see bus-agent FR-AGT-005, FR-AGT-005a). Bus-dev MUST pass through to bus-agent any user-configured agent order and enable/disable settings so that the available set and selection order match bus-agent’s contract. If no agent is available, the tool MUST exit with a clear diagnostic and non-zero exit code and MUST direct the user to install or enable at least one supported agent using the installation references provided by the bus-agent library. Acceptance criteria: running `bus dev work` with no `--agent` and no `BUS_DEV_AGENT` results in bus-agent selecting an available agent when at least one is available; when none is available, the tool exits with a clear message and does not proceed; tests can verify behavior by controlling PATH or by using bus-agent’s testability guarantees (stub executables, hermetic tests).

FR-DEV-005e Agent and model disclosure on each step. When the tool executes an agent-invoking step (plan, work, spec, or e2e), it MUST print to stderr, at the start of that step and before streaming or capturing agent output, which internal agent runtime and which model are in use. The runtime identifier and model string MUST be obtained from the bus-agent library (FR-AGT-011) and written in a single, stable, human-readable line so that logs and scripts can see which agent and model were used for that step. This applies to each step when multiple workflow operations are run in one invocation (e.g. `bus dev spec work e2e`): each of spec, work, and e2e MUST emit its own agent/model line at the start of that step. Acceptance criteria: every plan/work/spec/e2e invocation produces at least one such line on stderr before agent output; when stub or mock agent is used in tests, the line still reflects the resolved runtime and model (or placeholder when the backend does not report a model).

FR-DEV-005c Gemini integration is repository-local only. When the selected agent runtime is Gemini CLI, Bus Dev MUST create, edit, and rely only on repository-scoped files: a repo-root `GEMINI.md`, optional directory-scoped `GEMINI.md` files, `.gemini/settings.json` (for context discovery, ignore behavior, tool policy, and MCP configuration), and `.geminiignore` (for excluding files from context ingestion). Bus Dev MUST NOT modify any user-global Gemini configuration or memory (see NG-DEV-005). Acceptance criteria: no code path writes to `~/.gemini/` or any path outside the current repository; documentation describes the repo-local Gemini files and their roles; tests verify that the tool never invokes Gemini CLI in a way that would add or change global memory (e.g. no `/memory add` or equivalent).

FR-DEV-006 Commit subcommand behavior. The `bus dev commit` subcommand MUST implement behavior equivalent to the normative commit workflow specified in the Command Surface section below, including: do nothing and exit success when there is nothing staged (or working tree clean in the staged-set sense); operate strictly on the Git index; no file modification, no staging, no amend/rebase, no remote operations; depth-first submodule commits when submodules have staged changes; clear report and stop when a submodule commit causes an unstaged gitlink in the superproject; and enforce the commit message quality rules, atomicity guidance, and failure/hook handling rules as normative requirements. Acceptance criteria: the SDD defines these rules; the implementation enforces them; tests verify behavior with a fixture repo (including submodules when applicable).

FR-DEV-007 Work subcommand behavior. The `bus dev work` subcommand MUST implement the canonical "do the work in this repo now" agent-runner workflow equivalent to the provided work script: operate only inside the current module repository, follow the module’s Cursor rules and design docs, implement concrete code changes, add tests, run the Makefile checks, and update README.md before finishing. The agent MUST be allowed to read the repository’s own docs and Cursor rules as the authoritative specs for that repo. When `PLAN.md` exists at repository root, the embedded work prompt MUST instruct the agent to read it first and prioritize unchecked items in `PLAN.md` before proposing or executing additional work. When work completes an item from `PLAN.md`, the workflow MUST check off that item in `PLAN.md` (for example as `- [x]`). `bus dev work` MUST NOT remove already checked items from `PLAN.md`; pruning completed checked items is owned by `bus dev plan` (FR-DEV-011). When the selected runtime is Gemini CLI, the agent MUST also be able to use repository-local Gemini context (e.g. repo-root and directory-scoped `GEMINI.md`, `.gemini/settings.json`, `.geminiignore`) as documented in the Gemini CLI integration subsection; Bus Dev supports Cursor rules and Gemini context in parallel without changing core workflow contracts. In headless or script mode, the workflow MUST remain non-interactive and MUST NOT perform prohibited actions (especially network operations); see Headless and script mode below. Acceptance criteria: the workflow is driven by an embedded prompt template; no external prompt file is required; when `PLAN.md` exists the prompt consumes it before other task discovery; completed plan items are checked off by work; checked plan items are never removed by work; behavior is documented and testable via a stubbed agent; headless invocation does not trigger interactive or network operations.

FR-DEV-008 Spec subcommand behavior. The `bus dev spec` subcommand MUST refine only the current repository’s Cursor MDC rule file and nothing else, equivalent to the provided refine-mdc-spec script. The tool MUST locate the current module’s MDC file deterministically (e.g. `.cursor/rules/<module>.mdc`), MUST fail with a clear non-zero error if that file does not exist, and MUST run an embedded refinement prompt that instructs the agent to update only that MDC file and to align it with the latest BusDK specs. Acceptance criteria: no refinement of source code, tests, or README; the MDC path is derived from module identity; missing MDC exits non-zero with a clear message.

FR-DEV-009 E2E subcommand behavior. The `bus dev e2e` subcommand MUST provide a guided workflow to detect missing end-to-end tests for the current module repository and scaffold them in a hermetic way, consistent with BusDK testing conventions and the module’s SDD and end-user documentation. E2E tests are Bash shell scripts that run the module’s compiled binary; they MUST live under the `tests/` directory and MUST be named `e2e_bus_<name>.sh` where `<name>` is the module name with the `bus-` prefix stripped (e.g. module `bus-accounts` → `tests/e2e_bus_accounts.sh`). Each bus module MUST also implement complete unit tests; e2e and unit-test conventions are described in agent-specific configurations (e.g. Cursor MDC rules). The tool MUST use the module’s SDD and end-user documentation to determine which tests are needed and MUST produce scaffolds that cover the behavior described there; language- and module-specific details are defined in agent rules. When `PLAN.md` exists at repository root, the embedded e2e prompt MUST instruct the agent to read it first, verify that each checked item is fully covered by e2e tests, and prioritize unchecked test-related items from the plan before proposing additional test scope. Independently of `PLAN.md`, the command MUST continue discovering other untested behavior required by the module SDD and end-user docs. `bus dev e2e` MUST NOT remove already checked items from `PLAN.md`; pruning completed checked items is owned by `bus dev plan` (FR-DEV-011). Acceptance criteria: the command detects missing e2e tests by consulting the module SDD and end-user docs; when `PLAN.md` exists the prompt consumes it before additional discovery; checked plan items are validated against e2e coverage; other untested documented behavior is still discovered; checked plan items are never removed by e2e; scaffold output uses the `tests/e2e_bus_<name>.sh` layout and naming; scaffold content is deterministic and aligned with those sources and with agent rules; the command has defined preconditions and safety constraints.

FR-DEV-010 Init subcommand behavior. The `bus dev init [DIR] [--lang go] [spec|work|e2e ...]` subcommand MUST initialize module-root files without performing any Git operations, and MUST run workflow operations only when they are explicitly appended after init. Behavior MUST be equivalent to: (1) resolve the target directory as current working directory when `DIR` is omitted, or as `DIR` when provided; (2) if `DIR` is provided and does not exist, create it; if the resolved target path exists but is not a directory, exit with code 2 and a clear error; (3) ensure `.cursor/rules` exists in the target directory; (4) ensure the module MDC file exists at `.cursor/rules/<module>.mdc`, where `<module>` is the base name of the target directory and default MDC content MAY depend on `--lang`; (5) ensure a root `Makefile` exists, creating it from an embedded sample Makefile when missing; (6) if one or more workflow operations are appended after init, set the effective working directory to the target directory and execute those operations exactly in the order provided. The `--lang` flag MUST default to `go` and MUST control which kind of default MDC content the tool installs for future multi-language support. Acceptance criteria: no Git commands are executed; running `bus dev init` initializes only the current directory and does not invoke spec/work/e2e; running `bus dev init DIR` performs the same initialization in DIR; running `bus dev init [DIR] spec work e2e` runs all listed operations in that exact order and stops on first failure; initialization creates missing scaffold files and does not overwrite an existing `Makefile` by default; tests verify both default init-only behavior and ordered optional workflow execution.

FR-DEV-011 Plan subcommand behavior. The `bus dev plan` subcommand MUST review online documentation and current repository content to produce a compact task plan in `PLAN.md` at repository root. The required documentation inputs are: the main SDD URL (`MAIN_SDD_URL`), the current module SDD URL (`MODULE_SDD_URL`), the current module end-user docs URL (`MODULE_DOCS_URL`), and any project SDD pages directly relevant to requirements found in those pages. The command MUST detect unimplemented features and other undone work by comparing documented requirements and expected behavior to the current repository. If `PLAN.md` already exists, the command MUST re-validate existing items against current repository state and current documentation, remove items that are already done (including previously checked items), retain items that are still undone, and then add any newly detected missing work. The command MUST write only `PLAN.md` and MUST NOT modify source files, tests, or other docs. `PLAN.md` content written by `bus dev plan` MUST be a compact unchecked Markdown task list, with one unchecked item per still-undone or newly detected unimplemented feature or undone work item, ordered from highest to lowest priority. Each item MUST be short and action-oriented, with enough context for an agent to choose the next task, and MUST avoid implementation details that belong in the project SDD and related docs. Acceptance criteria: `bus dev plan` creates or overwrites `PLAN.md` deterministically for the same repository and docs inputs; when `PLAN.md` existed before the run, completed items (including checked ones) are removed and still-valid undone items are preserved or rephrased compactly; newly detected missing work is appended into the same prioritized list; every listed item is unchecked (`- [ ]`); list ordering reflects priority; no implementation-level steps are included; no files other than `PLAN.md` are changed.

NFR-DEV-001 Determinism. Output and exit codes MUST be deterministic for the same inputs and repository state. Acceptance criteria: repeated runs with the same staged set and same repo state yield the same exit code and consistent diagnostics.

NFR-DEV-002 No remote operations. The implementation MUST NOT perform any Git operation that contacts a remote. Acceptance criteria: no code path may call push, pull, fetch, clone, or submodule update/init in a way that touches a remote; tests and code review can verify this.

NFR-DEV-003 Hermetic tests. Tests MUST be hermetic: no network, no real external services, no reliance on a real agent runtime (e.g. Cursor CLI, Codex, Gemini CLI, or Claude CLI) or remote. Acceptance criteria: unit tests and fixture-based tests run in CI without network; agent invocation is tested by stubbing the agent binary in PATH and feeding deterministic NDJSON or output to exercise parsing, filtering, and error handling.

NFR-DEV-004 Cross-platform. Behavior and tests MUST be defined so they can run on Linux and macOS in line with the project’s CI. Acceptance criteria: no OS-specific assumptions are left unspecified; where behavior differs by platform, it is documented.

NFR-DEV-005 Security. The tool MUST NOT execute arbitrary code from repository content. The only permitted external execution is: the configured agent runtime (with embedded prompts) and local `git` for the commit workflow (NFR-DEV-002 covers the no-remote constraint). Acceptance criteria: no execution of repository-provided scripts or binaries; agent and Git usage are the only defined execution boundaries.

NFR-DEV-006 Maintainability. The bus-agent integration and subcommand handlers MUST be testable in isolation with stubbed dependencies (e.g. stub agent in PATH as supported by bus-agent, fixture repositories). Prompts and derivation rules MUST be documented in this SDD so that behavior can be verified without reading source. Acceptance criteria: unit tests cover repo resolution, flag parsing, and subcommand flow with bus-agent stubbed or stub executable in PATH; design docs are the single source of truth for derivation and command semantics.

### System Architecture

Bus Dev is a thin CLI that delegates to testable packages. The main entrypoint is `Run(args, workdir, stdout, stderr) int`; the `main` package calls it and exits with its return value. No `os.Exit` is used outside `main`, so behavior is testable without process exit.

High-level components:

- **CLI layer.** Parses global flags (including BusDK-standard `-C`, `-o`, `-v`, `-q`, `--help`, `--version`) and the `bus dev` operation(s), resolves the effective working directory, and resolves the agent runtime selection: per-command flag overrides session-stored preference; when neither is set, the implementation delegates to bus-agent for the automatic default from available runtimes in bus-agent’s order (alphabetic when no user order is configured; user can configure order and enable/disable per bus-agent FR-AGT-005a) (FR-DEV-005b, FR-DEV-005d). When an agent step runs, the tool prints to stderr which agent and model are in use (FR-DEV-005e). When multiple workflow operations (spec, work, e2e) are given, it runs them in order, delegating to each handler in sequence and stopping on first failure (FR-DEV-001a); otherwise it delegates to the single operation’s handler.

- **Repository and module resolution.** A small package (or internal function set) that, given a workdir, detects whether it is inside a Git repository, finds the repository root, and derives the module name when needed (e.g. for `bus dev plan`, `bus dev spec`, and `bus dev e2e`). The module name is the base name of the repository root directory (FR-DEV-003). This layer does not perform any Git write operations; it only reads repository metadata.

- **bus-agent library dependency.** Bus Dev does not implement an agent runner itself. It depends on the [bus-agent](./bus-agent) Go library for runtime selection, prompt-template rendering, command construction, timeout enforcement, and output capture or streaming. Subcommand handlers (plan, work, spec, e2e) pass workflow-specific prompt content and variables to bus-agent, which invokes the configured external agent (Cursor CLI, Codex, Gemini CLI, or Claude CLI) in the given workdir. Bus Dev supports both Cursor rules and Gemini context in parallel: workflow contracts do not change based on which backend is selected; the agent reads the repo’s Cursor rules and, when Gemini CLI is selected, the repo’s repository-local Gemini context as documented in the Gemini CLI integration subsection. In headless or script mode, bus-dev invokes bus-agent in a way that keeps workflows non-interactive and prevents prohibited actions (especially network operations); bus-agent’s script-safe contract supports this.

- **Subcommand handlers.** One logical component per operation: init, commit, plan, work, spec, e2e. Each handler receives parsed flags, the resolved workdir (and repo root and module name when relevant), and stdout/stderr writers, and returns an exit code. When the user invokes multiple workflow operations (e.g. `bus dev spec work e2e`, or `bus dev init [DIR] spec work e2e`), the CLI layer invokes each handler in order and stops on first non-zero exit (FR-DEV-001a). Init resolves the target directory (current directory by default), creates missing scaffold files (`.cursor/rules`, module MDC, and root `Makefile` from an embedded sample if missing), and by default does not invoke agent workflows; it invokes spec/work/e2e only when those operations are explicitly present after init. The plan handler derives documentation URLs, reads existing `PLAN.md` when present, drives the embedded planning prompt via bus-agent to re-validate prior items and discover new missing work, prunes completed checked items, and enforces that only repository-root `PLAN.md` is written. The work handler checks off completed plan items but does not delete checked items. The e2e handler validates checked plan items against e2e coverage and does not delete checked items. Commit may use Git only for read operations plus `git commit` with already-staged content; it must not stage, amend, or touch remotes.

- **Embedded prompts.** Prompts for commit, plan, work, spec, and (when applicable) e2e are compiled into the binary as string constants or templates. Templates use `{{VARIABLE}}` placeholders; variables are derived at runtime from the repository resolution layer and the docs base URL (see Prompt variable catalog and FR-DEV-004a). Bus-dev uses the bus-agent library for template rendering (or a contract-compatible implementation) so that rendering is deterministic and fails fast on missing or unresolved placeholders before any agent invocation. No prompts are loaded from the filesystem.

- **Log formatting (optional).** The NDJSON-to-text style formatter (equivalent to the provided format-cursor-log / ndjson-to-text behavior) may be provided by the bus-agent library or implemented locally when bus-dev streams agent output to stderr. The SDD treats this as the desired direction; whether it is a separate subcommand or only internal is left as an implementation detail, with the initial scope kept minimal and deterministic.

Data flow: user invokes `bus dev <subcommand>`; dispatcher runs `bus-dev <subcommand> [args]`; CLI parses args and workdir; repo resolution checks Git repo and optionally module name; subcommand handler runs (either Git + agent for commit, agent-only for plan/work/spec, or scaffold/detect for e2e). When an agent is used, the handler supplies embedded prompt template and variables to the bus-agent library, which renders the prompt and invokes the selected external agent; output is captured or streamed per bus-agent’s contract. All diagnostics to stderr, deterministic result/exit code.

### Key Decisions

KD-DEV-001 Git exception scoped to bus-dev. BusDK’s NG-001 (no Git execution) is relaxed only for the bus-dev module, and only for local, non-remote, non-rewriting operations, to support developer workflows without embedding Git logic in every other module.

KD-DEV-002 Prompts embedded in binary. Prompts are not loaded from the repository or from external files so that behavior is versioned with the binary and consistent across all module repos that use the same bus-dev version.

KD-DEV-003 Agent execution via bus-agent. The tool does not implement its own agent runner; it depends on the bus-agent Go library to invoke external agent runtimes. This keeps bus-dev focused on workflow semantics and prompts while bus-agent owns the runner abstraction, backends, and execution contract.

KD-DEV-004 Modular agent backends from bus-agent. Cursor CLI, Codex, Gemini CLI, and Claude CLI are supported as selectable backends through the bus-agent library. Bus-dev passes the user’s selection (or automatic default) to bus-agent, which provides the backend abstraction and preference order (FR-DEV-005d). Adding or changing runtimes is done in bus-agent; bus-dev’s subcommand semantics and embedded prompts do not change.

KD-DEV-005 Thin CLI, testable core. The CLI parses arguments and delegates to packages that take workdir and I/O writers; `Run(...) int` allows full unit and integration tests without spawning processes or calling `os.Exit`.

KD-DEV-006 E2E test convention. Bus module e2e tests are Bash scripts under `tests/` named `e2e_bus_<name>.sh`, running the compiled binary. Detection of missing tests and scaffold content are driven by the module’s SDD and end-user documentation; agent-specific rules (e.g. Cursor MDC) define language and module-specific testing expectations. Modules also implement full unit tests in addition to e2e.

### Component Design and Interfaces

Interface IF-DEV-001 (dispatcher). The `bus` dispatcher invokes the `bus-dev` binary with the remaining arguments after `dev`: global flags and one or more operation names. For `bus dev init [DIR]`, the first positional after flags is `init`; the next positional is optional and, when present and not one of `spec|work|e2e`, is treated as the target directory; any following operation tokens from `spec|work|e2e` are executed in order. For `bus dev commit`, the only operation is `commit`. For `bus dev plan`, the only operation is `plan`. For `bus dev spec work e2e` (or any sequence of spec, work, e2e), the binary receives those operation names in order and executes them in sequence (FR-DEV-001a). Standard global flags (`-C`, `-o`, `-v`, `-q`, `--help`, `--version`, etc.) follow BusDK CLI conventions. An agent selection flag (e.g. `--agent <runtime>`) and the session-stored preference (e.g. `BUS_DEV_AGENT`) are resolved as per FR-DEV-005b; see traceability links.

Interface IF-DEV-002 (Run entrypoint). The program exposes a single entrypoint `Run(args []string, workdir string, stdout, stderr io.Writer) int`. `main` passes `os.Args[1:]`, the effective working directory (from `-C` or current process), `os.Stdout`, and `os.Stderr`, and exits with the returned code. No other package calls `os.Exit`.

Interface IF-DEV-003 (bus-agent integration). Bus-dev invokes the bus-agent library’s runner interface (see [bus-agent](./bus-agent) IF-AGT-001) with: selected runtime (or leave resolution to bus-agent), prompt text (after rendering the embedded template with the prompt variable catalog), workdir, timeout, and output mode (capture/stream). Bus-agent returns an exit code and streams or captures output per its contract. Bus-dev does not implement this interface; it is a caller of the bus-agent package. Tests may stub the agent executable in PATH (as supported by bus-agent) or mock the bus-agent dependency to verify bus-dev’s workflow and prompt wiring without running a real agent.

Interface IF-DEV-004 (repo resolution). Given a directory path, the resolver returns: whether the path is inside a Git repository, the repository root path, and (when requested) the module name. For repository-scoped operations, module name MUST be the base name of the repository root directory (see FR-DEV-003). If not inside a repo, the resolver returns an error suitable for a clear user-facing message. `init` target naming is deterministic but does not require repo resolution; it uses the base name of the resolved target directory.

**Prompt variable catalog.** The following variables are available for substitution in embedded prompt templates (FR-DEV-004, FR-DEV-004a). All are derived at runtime from repository resolution, the configured docs base URL (FR-DEV-004b), or the operation context. Each prompt template documents which of these it uses; substitution MUST be complete before agent invocation (FR-DEV-004a).

| Variable | Description | Source / derivation |
| -------- | ----------- | ------------------- |
| `DOCS_BASE_URL` | Base URL for documentation; used to build all doc links. | `BUS_DEV_DOCS_BASE_URL` env (default `https://docs.busdk.com`), trailing slash trimmed. |
| `MAIN_SDD_URL` | URL of the main BusDK SDD index. | `<DOCS_BASE_URL>/sdd` |
| `MODULE_NAME` | Current module name (e.g. `bus-accounts`). | Base name of repository root directory (FR-DEV-003). |
| `MODULE_SUFFIX` | Module name with `bus-` prefix stripped (e.g. `accounts`). | Derived from `MODULE_NAME`. |
| `MODULE_SDD_URL` | URL of this module’s SDD page. | `<DOCS_BASE_URL>/sdd/<MODULE_NAME>` |
| `MODULE_DOCS_URL` | URL of this module’s end-user docs page. | `<DOCS_BASE_URL>/modules/<MODULE_NAME>` |
| `E2E_SCRIPT` | E2E script filename (e.g. `e2e_bus_accounts.sh`). | `e2e_bus_<MODULE_SUFFIX>.sh` |
| `E2E_SCRIPT_PATH` | Path to the E2E script under the repo (e.g. `tests/e2e_bus_accounts.sh`). | `tests/<E2E_SCRIPT>` |
| `E2E_WORKSPACE_DIR` | Absolute path to the repository root used as e2e workspace. | Resolved repo root. |
| `MDC_FILE` | Path to the module’s MDC rule file (e.g. `.cursor/rules/bus-accounts.mdc`). | `.cursor/rules/<MODULE_NAME>.mdc`. Spec-subcommand prompts only. |
| `PLAN_FILE` | Repository-local planning file used by plan/work/e2e (`PLAN.md`). | Literal value `PLAN.md` at repository root. |
| `PLAN_FILE_PATH` | Absolute path to `PLAN.md` in the current repository. | `<repo-root>/PLAN.md` |

`MDC_FILE` is used only in the spec subcommand’s prompt context. `PLAN_FILE` and `PLAN_FILE_PATH` are used by plan, and are also available to work and e2e so those prompts can read `PLAN.md` when present. The implementation MUST supply the expected placeholder set per template so that missing or unresolved placeholders are detected before agent invocation (FR-DEV-004a).

**Supported agent runtimes and installation references.** The set of supported runtimes (Cursor CLI, Codex, Gemini CLI, Claude CLI), their executable detection, and the canonical installation URLs for diagnostics are defined in the [bus-agent](./bus-agent) SDD (Component Design: Runtime installation references; FR-AGT-003, FR-AGT-010). Bus-dev MUST use the bus-agent library for execution and therefore uses the same runtimes and installation references; bus-dev does not duplicate this table or implement its own backends. When the selected agent is not installed or not in PATH, bus-dev surfaces the failure and installation reference as provided by bus-agent.

**Agent selection configuration.** The user selects which runtime to use in two ways. (1) **Per-command override:** A flag (e.g. `--agent cursor|codex|gemini|claude`) selects the runtime for that invocation only, so it is easy to switch for a single command. (2) **Session-stored preference:** An environment variable (e.g. `BUS_DEV_AGENT`) stores the user’s preferred runtime for the session; that value is used as the default for every `bus dev` command in that session until the variable is unset or changed. When neither flag nor session preference (nor any persistent preference) is set, bus-dev delegates to the bus-agent library for the **automatic default**: bus-agent determines the set of available runtimes (enabled runtimes minus any user-disabled, or restricted to user-enabled when an enable list is configured; see bus-agent FR-AGT-005a) and picks the first available runtime in the effective order — either the user-configured order (when provided) or alphabetical by runtime ID (FR-AGT-005). Bus-dev MUST pass through to bus-agent any user-configured agent order and enable/disable settings (e.g. via environment or config that bus-agent documents). Resolution order matches bus-agent’s FR-AGT-005: flag overrides session preference; session preference overrides automatic default; otherwise bus-agent’s automatic default applies. Invalid runtime names (e.g. `--agent unknown`) MUST produce a clear usage error and exit 2. If no agent is available when the automatic default would be used, the tool MUST exit with a clear diagnostic and direct the user to install or enable at least one supported agent using the installation references provided by bus-agent (see Error Handling). The executable name(s) used to detect each runtime are defined in the bus-agent SDD (IF-AGT-002). At the start of each agent step (plan, work, spec, e2e), the tool MUST print to stderr which internal agent and model are in use (FR-DEV-005e).

**Gemini CLI integration.** When the user selects Gemini CLI as the agent runtime, Bus Dev supports the same workflow as for Cursor (plan, work, spec, e2e) without changing core workflow contracts. In Gemini terms, "MDC-style configuration" means the use of project-level context and settings files that play a role analogous to Cursor’s `.cursor/rules/*.mdc` and project settings: the Gemini CLI loads context from markdown files (by default `GEMINI.md`) and respects a project `.gemini/settings.json` and `.geminiignore`. Bus Dev documents and, where applicable, creates or updates only the repository-local layer so that both Cursor rules and Gemini context can be used in parallel for the same repo.

Hard boundary: Bus Dev MUST NOT modify any user-global Gemini configuration or memory. That includes `~/.gemini/GEMINI.md`, any other file under the user’s home Gemini config directory, and any global memory managed via interactive Gemini CLI commands such as `/memory add`. Bus Dev may read global context only if the Gemini CLI loads it by default when the agent is invoked; Bus Dev itself does not write, create, or edit anything outside the current repository (NG-DEV-005, FR-DEV-005c). Developers who want global Gemini memory or user-level Gemini config must manage it manually outside Bus Dev.

Repository-local files that Bus Dev may create, edit, or rely on are: (1) a repo-root `GEMINI.md` that supplies project-level instructions and context for the agent; (2) optional directory-scoped `GEMINI.md` files for subdirectory-specific context; (3) `.gemini/settings.json` for context discovery, ignore behavior, tool policy, and MCP configuration; and (4) `.geminiignore` for excluding files from context ingestion. The intended precedence and scoping model when the Gemini CLI runs is: global user context (loaded by the CLI from `~/.gemini/` and any user-managed memory) is applied first; then repository context from the repo-root `GEMINI.md` and `.gemini/settings.json`; then directory context from any `GEMINI.md` in the current or ancestor directories. Bus Dev’s responsibility is limited to documenting and managing the repository-local layer only; it does not configure or alter the global layer.

Example narrative of repo-local files and responsibilities: The repo-root `GEMINI.md` typically holds project-wide instructions, conventions, and links to design docs so that when `bus dev work` or `bus dev spec` invokes the Gemini CLI, the agent receives consistent project context. Directory-level `GEMINI.md` files (e.g. under `internal/` or `docs/`) can narrow scope for that subtree. The `.gemini/settings.json` file controls how the Gemini CLI discovers context files, which paths to ignore, tool usage policy, and MCP server configuration for that repo. The `.geminiignore` file lists patterns of files or directories to exclude from context ingestion, analogous to `.cursorignore` for Cursor. Bus Dev may scaffold or update these files during `bus dev init` or when documenting the layout; it never touches `~/.gemini/` or global memory.

### Command Surface

**Invocation.** The CLI is invoked as `bus dev [global-flags] <operation> [operation ...]`. Operations are: **init**, **commit**, **plan**, **spec**, **work**, **e2e**. The workflow operations **spec**, **work**, and **e2e** MAY be repeated in one invocation; when multiple are given, they run in the order given, one at a time, and the run stops on first failure (see FR-DEV-001a). `init` accepts an optional target directory and may be followed by zero or more workflow operations from the same set: `bus dev init [DIR] [spec|work|e2e ...]`. `plan` is a standalone operation that produces `PLAN.md`. Global flags apply as per BusDK CLI conventions. The agent runtime is selected by the `--agent` flag for that invocation, by the session-stored preference (e.g. `BUS_DEV_AGENT`), or automatically from enabled agents (those whose CLI exists in PATH) in a documented preference order when neither is set; see Agent selection configuration above.

**Headless and script mode.** When `bus dev` invokes an agent (plan, work, spec, e2e) from a non-interactive environment — for example from a script, CI, or a headless runner — the workflow MUST remain non-interactive and MUST NOT perform prohibited actions. Prohibited actions include network operations (e.g. the agent must not be instructed or allowed to push, pull, fetch, or call external APIs as part of the workflow), modifying user-global configuration or memory (see NG-DEV-005 and Gemini CLI integration), and any operation that would block waiting for user input. The implementation MUST invoke the selected agent with flags or environment that enforce non-interactive, script-safe behavior so that `bus dev plan`, `bus dev work`, `bus dev spec`, and `bus dev e2e` can be used in automation without requiring a TTY or user interaction. Exit codes and stderr output remain deterministic as specified elsewhere in this SDD.

**`bus dev init [DIR] [--lang go] [spec|work|e2e ...]`**

Intent: Initialize a BusDK module root in place, in the current working directory by default or in an explicitly provided target directory, without performing any Git operations. By default, init performs initialization only; it does not run spec, work, or e2e unless those operations are explicitly appended after init.

Preconditions: The effective working directory need not be a Git repository. If `DIR` is omitted, the target directory is the effective current working directory and must exist. If `DIR` is provided and does not exist, init creates it. If the target path exists but is not a directory, the command exits with code 2 and a clear message. Agent runtime availability is required only when appended operations (spec/work/e2e) are requested.

Reads: Existing repository files in the target directory (to detect whether scaffold files are already present), embedded init templates (including the sample Makefile), and BusDK documentation and embedded prompts only when appended operations are run. No workspace datasets.

Writes: Ensures `.cursor/rules` exists in the target directory. Ensures `.cursor/rules/<module>.mdc` exists, where `<module>` is the base name of the target directory, with default content controlled by `--lang` (default `go`). Ensures a root `Makefile` exists by writing an embedded sample Makefile when missing. If appended workflow operations are present, sets effective working directory to the target directory and runs them in the exact order provided by the command line.

Allowed mutations: Creating the target directory when needed, creating missing initialization files, and optionally writing changes produced by explicitly requested workflow operations under the target directory. No mutations outside the target directory. No Git operations.

Must never do: Run any Git command (no `git init`, no add, no commit). Run spec/work/e2e unless explicitly requested after init. Overwrite an existing `Makefile` by default during initialization. Create or modify anything outside the resolved target directory (except stderr and any documented stdout).

Language flag: `--lang` defaults to `go`. It controls which default or language-specific MDC content init installs at `.cursor/rules/<module>.mdc`, so init can scaffold modules for different programming languages. The set of supported values and their exact effect on installed content is implementation-defined and MUST be documented in the CLI reference.

**`bus dev commit`**

Intent: Create one or more commits from the currently staged changes only, with high-quality messages and strict safety rules, without touching remotes or history.

Preconditions: Effective working directory is the root of a Git repository (or a subdirectory of one). Optional: repository may contain submodules.

Reads: Git index and repository metadata (e.g. `git status`, `git diff --cached`). Does not read workspace datasets or accounting files for bookkeeping.

Writes: Only new commits created from the existing staging area (via `git commit`). Does not write to working tree files, does not create or modify files outside Git’s normal commit operation.

Allowed mutations: Creating new commit(s) from already-staged content. Committing in submodules first (depth-first), then the superproject only if it has staged changes. No other mutations.

Must never do: Modify files; stage anything (`git add`); amend, rebase, or rewrite history; push, pull, fetch, clone, or any remote operation; run hooks that are not the standard Git commit hooks (the tool may run `git commit`, which may run commit-msg/pre-commit etc.; the tool must not bypass or suppress hooks).

Behavior when nothing to commit: If there is nothing staged (and no staged changes in submodules that need committing), the command does nothing and exits with code 0. No commit is created, no error.

Submodules: If the repository has submodules and a submodule has staged changes, commit inside that submodule first (recursively depth-first). After all submodules with staged changes are committed, if the superproject has staged changes (including gitlink updates), commit the superproject. If a submodule commit resulted in an unstaged gitlink change in the superproject, the tool MUST report that clearly (e.g. to stderr) and STOP without staging that gitlink; the user must stage it manually if desired.

Commit message quality (normative): For every commit, the message MUST have a concise, action-oriented subject line in the imperative mood. A body MAY follow, separated by a blank line. The message SHOULD explain what changed and why, mention user-visible impact or risk when relevant, and include traceability (issue IDs or URLs) when helpful. Vague summaries are not acceptable. Conventional prefixes (feat, fix, docs, refactor, test, chore) MAY be used when they improve clarity but MUST NOT replace a precise subject.

Atomicity: Before creating each commit, the implementation (or the agent it invokes) MUST review the staged set at a high level. If the staged set contains multiple logical changes, the implementation/agent MUST propose an atomic commit split plan. By default, the tool commits exactly what is currently staged and MUST NOT alter the staging area to perform a split unless explicitly instructed.

Failures and hooks: If a commit is rejected by hooks (e.g. pre-commit, commit-msg), the tool MUST report the exact failure reason and output and suggest the minimal correction. The tool MUST NOT retry the commit automatically unless explicitly instructed.

**`bus dev work`**

Intent: Run the canonical "do the work in this repo now" agent workflow: implement code changes, add/update tests, run Makefile checks, and update README in the current module repository, following the module’s Cursor rules and design docs.

Preconditions: Effective working directory is inside a BusDK module Git repository. The repository contains Cursor rules and design docs that the agent will read. When the selected runtime is Gemini CLI, repository-local Gemini context (e.g. repo-root `GEMINI.md`, `.gemini/settings.json`, `.geminiignore`) may also be present; Bus Dev supports Cursor rules and Gemini context in parallel without changing this workflow.

Reads: Repository source code, `.cursor/rules/*.mdc`, design docs (e.g. SDD, CLI reference) as referenced by the rules, and `PLAN.md` when it exists. When `PLAN.md` exists, the prompt requires the agent to review it first and prioritize its unchecked items while retaining checked items as completed history until plan pruning. When Gemini CLI is selected, the agent also reads repo-root and directory-scoped `GEMINI.md`, `.gemini/settings.json`, and respects `.geminiignore` for context ingestion. The agent is allowed to read these as the authoritative specs for that repo. Bus Dev does not read or modify user-global Gemini config or memory; developers who want global Gemini memory must manage it manually outside Bus Dev.

Writes: Determined by the agent under the constraints of the embedded prompt (code, tests, README, and `PLAN.md` item check-offs when applicable). The tool itself does not write repository files directly; it only invokes the agent with the embedded prompt.

Allowed mutations: Whatever the embedded prompt permits (code, tests, README, and checking off completed `PLAN.md` items), under the rule that the agent operates only in the current module and follows the module’s rules.

Must never do: Invoke remote Git operations; operate outside the current module repository; change workspace accounting datasets; remove already checked items from `PLAN.md`; modify user-global Gemini configuration or memory (see Headless and script mode and Gemini CLI integration). In headless or script mode, the agent MUST NOT perform network operations or other prohibited actions.

Implementation note: The workflow is executed via an embedded prompt template shipped inside bus-dev. Documentation links in the prompt (e.g. main SDD, module SDD, module end-user docs) are derived from the configurable docs base URL (FR-DEV-004b) and the prompt variable catalog (`MAIN_SDD_URL`, `MODULE_SDD_URL`, `MODULE_DOCS_URL`). The agent runtime reads the repository’s own docs, Cursor rules, and (when Gemini is selected) repository-local Gemini context as part of doing the work; those are the authoritative specs for that repo. For a concrete picture of repo-local files and what each is responsible for, see the Gemini CLI integration subsection.

**`bus dev plan`**

Intent: Build a compact prioritized implementation plan for the current module repository by comparing documented requirements to repository reality, then write that plan to `PLAN.md`.

Preconditions: Effective working directory is inside a BusDK module Git repository. The agent runtime is available. Documentation URLs derived from the docs base URL are reachable to the selected runtime.

Reads: Repository files, current tests, current docs in the repository, existing `PLAN.md` when present, the main SDD URL (`MAIN_SDD_URL`), the current module SDD URL (`MODULE_SDD_URL`), the current module end-user docs URL (`MODULE_DOCS_URL`), and other project SDD pages relevant to requirement coverage. The prompt uses these sources to re-validate existing plan items and to detect unimplemented features and other undone work.

Writes: `PLAN.md` at repository root only. The file is a compact Markdown checklist with unchecked items ordered by priority.

Allowed mutations: Creating or overwriting repository-root `PLAN.md`.

Must never do: Modify source code, tests, README, module MDC files, or any file other than `PLAN.md`. Include implementation-level instructions that duplicate or override project SDD details.

Plan format contract: `PLAN.md` contains one unchecked item (`- [ ]`) per still-undone or newly detected unimplemented feature or undone work item that the command determines from documented sources and repository state. If `PLAN.md` already exists, its prior items are treated as candidates: items now completed are removed, and items still undone are retained and reprioritized with newly discovered items in one combined list. Items are concise and action-oriented, with enough context for the next execution step, and avoid implementation details because implementation must come from project SDD and related documentation. If no undone work is detected after re-validation, the file still exists and states that no open items were found.

**`bus dev spec`**

Intent: Refine only the current repository’s Cursor MDC rule file so it accurately reflects the latest BusDK specifications; no changes to source code, tests, or README.

Preconditions: Effective working directory is inside a BusDK module Git repository. The module’s MDC file must exist (e.g. `.cursor/rules/<module>.mdc`). When the selected runtime is Gemini CLI, Bus Dev uses repository-local Gemini context in parallel with Cursor rules; headless and script mode constraints apply as in Headless and script mode.

Reads: The current MDC file (subject of refinement), BusDK documentation (as referenced by the embedded prompt; links are derived from the docs base URL and prompt variables such as `MAIN_SDD_URL`, `MODULE_SDD_URL`, `MODULE_DOCS_URL`, and `MDC_FILE` per the prompt variable catalog). When Gemini CLI is selected, the agent may also use repo-local `GEMINI.md` and `.gemini/settings.json`. The agent may read the spec pages to align the MDC.

Writes: Only the single MDC file at the deterministic path. No other files. Bus Dev does not write to any user-global Gemini config or memory.

Allowed mutations: Updating the content of the MDC file only.

Must never do: Modify source code, tests, README, or any file other than the designated MDC file; perform Git operations other than those implied by the user saving the file (if the agent writes the file, the user may then commit).

Module MDC path: The tool MUST locate the MDC file deterministically. The path is `.cursor/rules/<module>.mdc` where `<module>` is the module name (base name of the repository root directory, per FR-DEV-003). If the file does not exist, the tool MUST exit with a clear non-zero error and MUST NOT invoke the agent.

**`bus dev e2e`**

Intent: Guided workflow to detect missing end-to-end tests for the current module and scaffold them in a hermetic way, consistent with BusDK testing conventions and the module’s SDD and end-user documentation.

Preconditions: Effective working directory is inside a BusDK module Git repository. The module has (or the tool can resolve) an SDD and end-user documentation so that required test coverage can be determined.

Reads: Repository layout, existing tests under `tests/`, the module’s SDD document, end-user documentation (e.g. CLI reference) for the current module, and `PLAN.md` when it exists. When `PLAN.md` exists, the prompt requires the agent to review it first, validate that each checked item is fully covered by e2e tests, and prioritize unchecked test-related items. Documentation links in the prompt are derived from the docs base URL (FR-DEV-004b) and the prompt variable catalog (`MAIN_SDD_URL`, `MODULE_SDD_URL`, `MODULE_DOCS_URL`, `E2E_SCRIPT`, `E2E_SCRIPT_PATH`, `E2E_WORKSPACE_DIR`, `PLAN_FILE`, `PLAN_FILE_PATH`). The tool uses these inputs both to verify checked-item coverage and to discover other untested behavior from the SDD and end-user docs. Agent-specific rules (e.g. Cursor MDC for the module) define language and module-specific testing expectations and are used when generating or refining scaffolds.

Writes: New or updated test files under `tests/` only. E2E scripts MUST be named `e2e_bus_<name>.sh` where `<name>` is the module name with the `bus-` prefix stripped (e.g. `bus-accounts` → `tests/e2e_bus_accounts.sh`). Scaffold content MUST align with the behavior described in the SDD and end-user docs and with agent rules. No modification of production code.

Allowed mutations: Adding or updating files under `tests/` (e.g. `e2e_bus_<name>.sh` and any agreed boilerplate) as defined by the subcommand’s acceptance criteria. If `PLAN.md` is touched by this workflow, checked items MUST be preserved and must not be removed.

Must never do: Remote Git operations; history rewriting; modifying workspace accounting datasets; removing already checked items from `PLAN.md`; non-hermetic or network-dependent test scaffolding.

Detection and scaffold: The tool detects missing e2e tests by comparing required coverage (derived from the module’s SDD and end-user documentation, with URLs supplied via the prompt variable catalog) to existing tests under `tests/`. When `PLAN.md` exists, checked items are treated as completed feature commitments and MUST be verified as fully covered by existing or newly scaffolded e2e tests; coverage gaps for checked items are reported and scaffolded. The command also continues discovering other untested documented behavior that may not appear in `PLAN.md`. The exact scaffold (file names, boilerplate, and suggested cases) is deterministic: it follows the `tests/e2e_bus_<name>.sh` naming and directory layout, and the content is generated to cover the behavior and CLI surface described in the SDD and end-user docs. Language- and module-specific details (e.g. how to build or invoke the binary, Go test layout) are defined in agent-specific configurations (e.g. Cursor MDC) and are used when the agent runs or when the tool produces guidance. When `bus dev e2e` invokes an agent, Headless and script mode and repository-local-only Gemini rules apply; the agent must not perform network operations or modify user-global Gemini config or memory.

### I/O Conventions

Standard output: Reserved for deterministic, machine-readable command results when a subcommand produces them. For subcommands that only invoke an agent and stream human-readable output, stdout may be unused or used for a final success message in a documented format.

Standard error: All diagnostics, progress, and human-readable agent output (e.g. NDJSON formatted to text) MUST go to stderr. This preserves the BusDK convention that stdout is for results and stderr for diagnostics. At the start of each agent-invoking step (plan, work, spec, e2e), the tool MUST write a single line to stderr that identifies the internal agent runtime and model in use for that step (FR-DEV-005e), so that logs and scripts can see which agent and model were used.

When an external agent is invoked, the agent’s raw output (e.g. NDJSON) may be piped through an internal formatter that writes readable text to stderr. The tool MUST NOT inject color or control sequences into stdout when the output is intended to be machine-readable.

Determinism: Given the same repository state, same staged set, and same flags, the tool MUST produce the same exit code and consistent stderr output (up to timing or non-deterministic agent output when an agent is used; the tool’s own messages and exit code must still be deterministic for the "no agent" and "stub agent" cases).

### Exit Codes

- 0: Success. For `bus dev commit`, "nothing to commit" is success (0).
- 1: Execution failure (e.g. Git command failed, hook failed, agent exited with error, timeout).
- 2: Invalid usage (e.g. unknown subcommand, invalid flag, missing required argument, or precondition not met in a way that is usage-related — e.g. not in a Git repo, or MDC file missing for `bus dev spec`).

The distinction between invalid usage (2) and execution failure (1) follows BusDK CLI conventions: usage errors are 2; failures during an otherwise valid invocation are 1.

### Error Handling and Resilience

- **Configured agent runtime not installed or not in PATH:** When the user has selected an agent (via flag or session preference) and that agent’s CLI is not found or not executable, the tool MUST surface the failure from the bus-agent library and MUST exit with a clear diagnostic to stderr and a non-zero exit code (1). The message MUST indicate that the selected agent runtime could not be found or executed and MUST direct the user to the canonical installation URL for that runtime; bus-agent provides the installation reference (FR-AGT-010) and bus-dev uses it in the diagnostic.
- **No agent available (automatic default):** When no runtime is selected via flag or session preference and the automatic default would apply, but no agent is available (no enabled CLI in PATH, or all are disabled, or enable list excludes all), the tool MUST exit with a clear diagnostic to stderr and a non-zero exit code (1 or 2). The message MUST state that at least one supported agent runtime must be installed or enabled and MUST direct the user to the canonical installation URLs; bus-dev uses the installation references provided by the bus-agent library to build this message.
- **git not installed or not in PATH:** When a subcommand needs Git, the tool MUST detect failure to run `git` and MUST exit with a clear diagnostic and non-zero exit code (1).
- **Working directory not a Git repo:** For subcommands that require a Git repository (commit, plan, work, spec, e2e when run standalone), exit with code 2 and a clear message. For `bus dev init`, the effective working directory need not be a Git repository; init targets the current directory by default or the provided `DIR` path and initializes missing files there.
- **No staged changes (commit):** Exit 0 and do nothing; optionally print a short message to stderr that there was nothing to commit.
- **Hooks fail (commit):** Exit 1 and report the hook failure output; do not retry.
- **Timeouts (agent subcommands):** When the agent run (via the bus-agent library) exceeds the configured timeout, the tool MUST exit with a non-zero code (1) and MUST report that the run timed out.

All error messages MUST be written to stderr. The tool MUST NOT crash or exit with an ambiguous code when the above conditions occur; behavior MUST be as specified.

### Data Design

Bus Dev does not own or read workspace datasets (CSV, schemas, datapackage.json) for bookkeeping. It operates on:

- The Git repository (metadata and index) for the current working directory.
- The repository’s working tree (source files, `.cursor/rules/*.mdc`) when the agent is run, so the agent can read and optionally write files under the repo. When Gemini CLI is selected, Bus Dev only creates, edits, or relies on repository-scoped Gemini files: repo-root and optional directory-scoped `GEMINI.md`, `.gemini/settings.json`, and `.geminiignore`. Bus Dev never writes to the user’s home Gemini config directory (e.g. `~/.gemini/`) or to global memory (FR-DEV-005c, NG-DEV-005).
- Repository-root `PLAN.md` for planning continuity. `bus dev plan` creates or refreshes it as a compact unchecked priority list by re-validating existing items, removing completed checked items, and adding newly detected missing work. `bus dev work` reads it when present, prioritizes unchecked items, and checks off completed items without deleting checked items. `bus dev e2e` reads it when present, validates checked items against e2e coverage, prioritizes unchecked test-related items, and does not delete checked items.
- No persistent data store beyond what Git and the filesystem provide for bus-dev’s own state. Agent selection uses flags and environment variables: the per-command `--agent` flag and the session-stored preference (e.g. `BUS_DEV_AGENT`) override the automatic default; when neither is set, the implementation delegates to bus-agent, which determines available runtimes (from enabled runtimes and user-configured enable/disable and order) and picks the first in the effective order, alphabetically by default (FR-DEV-005b, FR-DEV-005d). User-configured agent order and enable/disable are passed through to bus-agent (e.g. via environment or config that bus-agent documents). No bus-dev-specific config file is required for agent selection, though the implementation MAY support an optional persistent config file as a fallback before the automatic default.

### Assumptions and Dependencies

AD-DEV-001 Git is available. The commit workflow and repository resolution depend on `git` being in PATH and the repository being a valid Git repo. If Git is missing or the directory is not a repo, the tool fails with a clear error.

AD-DEV-002 Agent runtime availability. Subcommands that invoke an agent (plan, work, spec, and e2e) require the chosen agent runtime (Cursor CLI, Codex, Gemini CLI, or Claude CLI) to be installed and in PATH when those subcommands are run. The chosen runtime is either explicitly selected (flag or session preference) or the automatic default (first available agent in bus-agent’s effective order, alphabetic when no user order is set). If the explicitly selected agent is missing, the tool reports that and exits non-zero; it does not silently fall back. If no agent is selected and none are available, the tool exits with a clear message directing the user to install or enable at least one supported agent (FR-DEV-005d).

AD-DEV-003 Repository layout. For `bus dev spec`, the module’s MDC file is assumed to live at `.cursor/rules/<module>.mdc` where `<module>` is the module name (base name of repository root directory, per FR-DEV-003). If the project adopts a different convention, this assumption will be updated in the SDD.

AD-DEV-004 Operating environment. Same as BusDK: Linux and macOS. Tests and behavior are defined for these environments; Windows is out of scope unless otherwise stated.

AD-DEV-005 bus-agent dependency. Bus Dev depends on the bus-agent Go module for agent execution. The bus-agent library provides the runner interface, supported runtimes (Cursor, Codex, Gemini, Claude), runtime detection, selection resolution, prompt-template rendering contract, timeout enforcement, output capture/streaming, and installation references for diagnostics. If bus-agent is unavailable or its interface changes in an incompatible way, bus-dev’s agent-invoking subcommands (plan, work, spec, and e2e) are affected; bus-dev does not implement a fallback agent runner.

### Testing Strategy

- **Unit tests.** All library-style code (repo resolution, argument parsing including multiple operations (FR-DEV-001a), init target resolution and scaffold creation, prompt template expansion, and agent invocation via bus-agent with stub) MUST have unit tests. Tests MUST be hermetic: no network, no real Git remotes, no real agent. Parsing and execution of multi-op invocations (e.g. spec, work, e2e in one call, and init with appended operations) MUST be covered; when a stub agent returns non-zero for the second operation, the third MUST not run and the exit code MUST be that of the failed operation. Tests MUST verify that plain `bus dev init` does not invoke any agent operation and that a missing root `Makefile` is created from the embedded sample while an existing `Makefile` is preserved. Plan-specific tests MUST verify that `bus dev plan` writes only `PLAN.md`, produces only unchecked checklist items, orders them by priority, and keeps item text compact and non-implementation-specific. Plan-specific tests MUST also verify rerun behavior when `PLAN.md` already exists: completed checked items are removed, still-undone items remain, and newly detected missing work is added. Work-specific tests MUST verify that completed plan items are checked off and that checked items are never removed by work. E2E-specific tests MUST verify checked-item coverage validation and additional untested-feature discovery from SDD/docs while preserving checked plan items.

- **Prompt rendering tests.** Unit tests MUST cover the prompt-template rendering contract (FR-DEV-004a): (1) missing variable — when a required variable is not supplied, the command MUST fail with a clear diagnostic and exit code 2 before any agent invocation; (2) unresolved variable — when any `{{...}}` token remains after substitution, the command MUST fail with a clear diagnostic and exit code 2 before agent invocation; (3) repeated placeholder replacement — the same variable MAY appear multiple times in a template and each occurrence MUST be replaced consistently; (4) expected placeholder set per prompt template — each template’s required variables MUST be documented and tests MUST verify that supplying that set yields a fully resolved prompt; (5) docs base override — when `BUS_DEV_DOCS_BASE_URL` is set (and when unset), derived URLs (`MAIN_SDD_URL`, module SDD URL, module docs URL) MUST match the specified formulas and normalization (trailing slash trimmed). Tests for work and e2e prompts MUST verify that `PLAN.md` is included in prompt context when present and omitted cleanly when absent, and that prompt instructions enforce the checked-item lifecycle rules.

- **Fixture repository.** At least one end-to-end style test MUST use a fixture Git repository in a temporary directory (e.g. a repo with a few commits and optionally a submodule) to verify commit behavior: nothing to commit exits 0, staged change leads to commit with message, submodule ordering, unstaged gitlink handling, etc. This test MUST not push or pull; it may run `git commit` only.

- **Agent runner tests.** When the agent is involved, the test strategy MUST stub the agent binary in PATH (or inject a fake path). The stub MUST feed deterministic NDJSON (or plain output) to stdout and exit with a chosen code so that parsing, filtering, and error handling are exercised without calling a real agent or network. Agent detection and automatic default selection (FR-DEV-005d) MUST be testable by controlling PATH so that zero, one, or multiple agent CLIs appear to exist; tests MUST verify that the chosen default is deterministic and that "no agent enabled" yields a clear exit and diagnostic.

- **Definition of Done.** For any implementation of this SDD, the following are required: unit tests for the new or touched code paths, at least one end-to-end style test using a fixture repo as above, and README updates that document the subcommands and link to this SDD and the canonical BusDK design spec where relevant.

### Traceability to BusDK Spec

This module intentionally deviates from the following BusDK design spec elements, and is constrained by the following:

- **NG-001 (BusDK does not execute Git commands).** Bus Dev is the defined exception: it may run local Git commands (status, diff, commit) under the strict constraints in this SDD (no remote, no history rewrite, no staging). Rationale: developer workflow centralization without putting Git into every module.

- **CLI conventions.** Bus Dev follows the same global CLI conventions as other modules (e.g. [Error handling, dry-run, and diagnostics](../cli/error-handling-dry-run-diagnostics), [Command structure and discoverability](../cli/command-structure)) for flags, stdout/stderr, and exit codes. Where it invokes an external agent, it still obeys the convention that machine-readable output (if any) is on stdout and diagnostics on stderr.

- **Module structure.** Bus Dev is implemented as a library-first, thin-CLI module consistent with [Module repository structure and dependency rules](../implementation/module-repository-structure) and [Independent modules](../architecture/independent-modules). It depends on the [bus-agent](./bus-agent) Go library for agent execution and does not implement its own agent runner; it does not invoke other `bus-*` binaries as subprocesses.

- **Testing.** The testing strategy aligns with the BusDK [Testing strategy](../testing/testing-strategy): hermetic, no network, deterministic, and with command-level or fixture-based tests where appropriate.

The most relevant BusDK spec pages for implementors are: the [BusDK Software Design Document (SDD)](../sdd) (goals and non-goals, especially NG-001), [CLI tooling and workflow](../cli/index), [Error handling, dry-run, and diagnostics](../cli/error-handling-dry-run-diagnostics), [Module repository structure and dependency rules](../implementation/module-repository-structure), and [Testing strategy](../testing/testing-strategy).

### Glossary and Terminology

- **Module name:** The identifier used for the current repository when a subcommand needs it (e.g. for the MDC path or docs URLs). It is derived deterministically as the base name of the repository root directory (the last path component of the absolute path to the repo root). See FR-DEV-003 and IF-DEV-004.

- **Staging area / Git index:** The set of changes that have been `git add`ed and will be included in the next `git commit`. Bus Dev commit operates only on this set; it does not add or remove from it.
- **Gitlink:** The Git submodule pointer (commit SHA) stored in the superproject tree for a submodule. When you commit inside a submodule, the superproject’s view of that submodule becomes an unstaged gitlink change until the user stages it.
- **MDC file:** A Cursor rule file in Markdown with optional frontmatter (e.g. `.cursor/rules/<name>.mdc`). Bus Dev spec refines exactly one such file per run. Init ensures the module MDC file exists, creating default content when missing; that content may depend on `--lang`.
- **Agent runner:** The abstraction that invokes the configured external agent runtime (Cursor CLI, Codex, Gemini CLI, or Claude CLI) with a prompt, timeout, and output formatting. In bus-dev this is provided by the [bus-agent](./bus-agent) Go library; bus-dev does not implement the runner itself. The active runtime is selectable via a flag or environment variable; supported runtimes and backends are defined in the bus-agent SDD.

- **Cursor CLI:** One of the supported agent runtimes. The Cursor CLI backend invokes the cursor-agent (or equivalent) executable. Used when the user selects the Cursor CLI option.

- **Codex:** One of the supported agent runtimes. The Codex backend invokes the Codex CLI (or equivalent) executable. Used when the user selects the Codex option. Integration is modular so that prompt, workdir, and I/O contract are the same across all backends.

- **Gemini CLI:** One of the supported agent runtimes. The Gemini CLI backend invokes the Gemini CLI (or equivalent) executable. Used when the user selects the Gemini CLI option. Integration is modular so that prompt, workdir, and I/O contract are the same as for other backends. Bus Dev supports repository-local Gemini context (e.g. `GEMINI.md`, `.gemini/settings.json`, `.geminiignore`) in parallel with Cursor rules and never modifies user-global Gemini configuration or memory (see Gemini CLI integration and NG-DEV-005).

- **MDC-style configuration (Gemini):** In Gemini CLI terms, the use of project-level context and settings files that play a role analogous to Cursor’s `.cursor/rules/*.mdc` and project settings: the Gemini CLI loads context from markdown files (by default `GEMINI.md`) and respects a project `.gemini/settings.json` and `.geminiignore`. Bus Dev documents and manages only the repository-local layer of this configuration.

- **PLAN.md:** Repository-root compact priority task list generated by `bus dev plan`. Each task written by `bus dev plan` is an unchecked item for one still-undone or newly detected unimplemented feature or other undone work item from documentation and repository state. `bus dev work` checks off items it completes and preserves previously checked items. `bus dev e2e` uses checked items as completed-feature coverage obligations and preserves checked items. On rerun, `bus dev plan` is the only command that prunes completed checked items and merges newly detected missing work into the prioritized unchecked list.

- **Repository-local (Gemini):** The set of Gemini-related files that Bus Dev may create, edit, or rely on, all under the current repository: repo-root `GEMINI.md`, optional directory-scoped `GEMINI.md`, `.gemini/settings.json`, and `.geminiignore`. Contrast with user-global Gemini config (e.g. `~/.gemini/GEMINI.md`) and global memory, which Bus Dev must never modify.

- **Headless and script mode:** Invocation of `bus dev` (and thus of the agent) from a non-interactive environment (script, CI, headless runner). In this mode workflows MUST remain non-interactive and MUST NOT perform prohibited actions such as network operations or modifying user-global Gemini config or memory.

- **Claude CLI:** One of the supported agent runtimes. The Claude CLI backend invokes the Claude CLI (or equivalent) executable. Used when the user selects the Claude CLI option. Integration is modular so that prompt, workdir, and I/O contract are the same as for other backends.

- **Enabled agent:** An agent runtime whose CLI command exists at resolution time (e.g. the corresponding executable is found in PATH and is executable). The **available** set for automatic default is determined by bus-agent and may be restricted by user-configured enable/disable (FR-AGT-005a). When the user does not specify a runtime, bus-dev delegates to bus-agent for the automatic default from available runtimes in bus-agent’s order (alphabetic when no user order is set) (FR-DEV-005d).

- **Session-stored preference:** The user’s default choice of agent runtime for the current session. Stored in an environment variable (e.g. `BUS_DEV_AGENT`) so that every `bus dev` command in that shell session uses that runtime unless overridden by the `--agent` flag. Easy to change by re-exporting the variable or by using the flag for a single command.

- **Embedded prompt:** A prompt string or template compiled into the bus-dev binary, not loaded from the filesystem.

- **DOCS_BASE_URL:** The base URL for BusDK documentation used to build all documentation links in prompts and diagnostics. Configurable via `BUS_DEV_DOCS_BASE_URL` (default `https://docs.busdk.com`); normalized by trimming a trailing slash. See FR-DEV-004b and the prompt variable catalog.

- **MAIN_SDD_URL:** The URL of the main BusDK SDD index page. Derived as `<DOCS_BASE_URL>/sdd`. Used in prompts and diagnostics when referring to the design spec. See FR-DEV-004b and the prompt variable catalog.

- **Prompt-template variable rendering contract:** The normative behavior for substituting `{{VARIABLE}}` placeholders in embedded prompts: rendering MUST be deterministic; missing or unresolved placeholders MUST cause the command to fail before agent invocation (exit code 2). Ensures the agent never receives partially substituted text. See FR-DEV-004a, NFR-DEV-001, NFR-DEV-005.

- **E2E test script (Bus module):** A Bash script that runs the module’s compiled binary to exercise end-to-end behavior. It MUST live under `tests/` and MUST be named `e2e_bus_<name>.sh` where `<name>` is the module name with the `bus-` prefix stripped (e.g. `bus-accounts` → `tests/e2e_bus_accounts.sh`). See KD-DEV-006 and FR-DEV-009.

---

<!-- busdk-docs-nav start -->
<p class="busdk-prev-next">
  <span class="busdk-prev-next-item busdk-prev">&larr; <a href="./bus-data">bus-data</a></span>
  <span class="busdk-prev-next-item busdk-index"><a href="./index">SDD index</a></span>
  <span class="busdk-prev-next-item busdk-next"><a href="./bus-bfl">bus-bfl</a> &rarr;</span>
</p>
<!-- busdk-docs-nav end -->

### Sources

- [bus-agent module SDD](./bus-agent)
- [bus-config module SDD](./bus-config)
- [BusDK Software Design Document (SDD)](../sdd)
- [CLI tooling and workflow](../cli/index)
- [Error handling, dry-run, and diagnostics](../cli/error-handling-dry-run-diagnostics)
- [Module repository structure and dependency rules](../implementation/module-repository-structure)
- [Testing strategy](../testing/testing-strategy)
- [End user documentation: bus-dev CLI reference](../modules/bus-dev)
- [Gemini CLI — install](https://geminicli.com/)
- [Cursor CLI — overview and install](https://cursor.com/docs/cli/overview)
- [Claude Code — get started / install](https://github.com/anthropics/claude-code?tab=readme-ov-file#get-started)
- [Codex CLI — install](https://developers.openai.com/codex/cli/)

### Document control

Title: bus-dev module SDD  
Project: BusDK  
Document ID: `BUSDK-MOD-DEV`  
Version: 2026-02-13  
Status: Draft  
Last updated: 2026-02-13  
Owner: BusDK development team  
